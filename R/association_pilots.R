
#' @title Test formulas for modeling tile accessibility as a function of gene expression.
#'
#' @description \code{pilot_GeneTile} Test formulas for zero-inflated GLMM-based modeling of tile accessibility 
#'                    as a function of gene expression. \code{\link[glmmTMB]{glmmTMB}}. 
#'
#' @param atacSE A MOCHA Tile-by-Sample Object (SummarizedExperiment)generated from getSampleTileMatrix within \code{\link[MOCHA]{MOCHA}}. 
#' @param rnaSE A ChAI scRNA object (SummarizedExperiment object) generated by \code{makePseudobulkRNA}
#' @param cellPopulation - name of the assay (cell population) to extract and use from rnaSE and atacSE
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from atacSE and rnaSE. This is used for aligning atacSE and rnaSE
#' @param continuousFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect). 
#'          Exp1 will be the dummy veriable for accessibility, while exp2 will be the dummy variable for gene expression. 
#' @param ziFormula list of  to tests from atacSE to test. 
#' @param zi_threshold Zero-inflated threshold ( range = 0-1), representing the fraction of samples with zeros. At or above this threshold, the zero-inflated modeling kicks in.
#'            We don't recommend changing this unless you have fully tested out the model and understand what it is doing. 
#' @param geneList a list of genes from rnaSE to test. 
#' @param tileList optional list of tiles to test. Default is NULL, which will test all tiles within the provided distance of the TSS. 
#' @param distance A number limiting the distance between tiles and genes TSS at which point associations will not be tested. 
#' @param samplingNumber An integer or a list of pairs (e.g. Protein1_TranscriptionFactor1). 
#'     If an integer, it will randomly pull that many pairs from all possible combinations of sig1 and sig2, returning the model outputs. 
#'    If a list of pairs is provided as a list of strings, it will only test those. These pairs should be a subset of all possible pairs of sig1 and sig2.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 2.
#'
#' @return A named list of model outputs
#'
#'
#'
#' @examples
#' \dontrun{
#'   modelList <- pilot_TilesGeneLinks(STM, 
#'                            'CD16 Mono',
#'                            exp~ Age + Sex + days_since_symptoms + (1|PTID),
#'                             ~ FragNumber, verbose = TRUE )
#' }
#'
#' @export
#' @keywords pilot_associations
#'

pilot_GeneTile <- function(atacSE, rnaSE, cellPopulation, sampleColumn, 
                                    continuousFormula, 
                                    ziFormula, 
                                    zi_threshold = 0,
                                    geneList, 
                                    tileList = NULL,
                                    distance = 10^6,
                                    samplingNumber = 5,
                                    numCores = 2) {

  if (!requireNamespace("MOCHA", quietly = TRUE)) {
      stop(
      "Package 'MOCHA' is required for pilot_GeneTile. ",
      "Please install 'MOCHA' to proceed."
      )
  }

  if(isChAIObject(atacSE, type = 'data', returnType = TRUE) != 'scATAC'){

    stop('atacSE is not a SampleTileMatrix Object from MOCHA.')

  }

  if(isChAIObject(rnaSE, type = 'data', returnType = TRUE) != 'scRNA'){

    stop('rnaSE is not a ChAI scRNA Object (normalized, pseudobulked via ChAI.)')

  }

  if(!sampleColumn %in% colnames(SummarizedExperiment::colData(atacSE)) |
          !sampleColumn %in% colnames(SummarizedExperiment::colData(rnaSE))){
      
    stop('sampleColumn missing from atacSE and/or rnaSE.')
      
  }

  #Check whether samples align.     
  if(!all(atacSE@colData[,sampleColumn] %in% rnaSE@colData[,sampleColumn]) |
      !all(rnaSE@colData[,sampleColumn] %in% atacSE@colData[,sampleColumn])) {
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in rnaSE and atacSE via ${sampleColumn}.'))
  }else if(!all(atacSE@colData[,sampleColumn] == rnaSE@colData[,sampleColumn])){
      warning('Reording rnaSE sample names to match atacSE.')
      rnaSE <- rnaSE[,match(atacSE@colData[,sampleColumn], rnaSE@colData[,sampleColumn])]
  }

  if(any(c(colnames(SummarizedExperiment::colData(atacSE)), 
      colnames(SummarizedExperiment::colData(rnaSE))) %in% c('exp1','exp2'))){

    stop('metadata of atacSE and/or rnaSE contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from atacSE and rnaSE, not the metadata.
    Please remove these and try again.')

  }

    #Test whether tileList and geneList are found in their assays.
  if(!all(geneList %in% rownames(rnaSE))){
     stop('geneList not found within rnaSE. Please read check that your genes of interest are present in rnaSE.')
  }
    
  if (methods::is(continuousFormula, 'character')) {
    continuousFormula <- stats::as.formula(continuousFormula)
  }

  if (methods::is(ziFormula, 'character')) {
    ziFormula <- stats::as.formula(ziFormula)
  }

  #Subset down to one cell type
  if (length(cellPopulation) > 1) {
  stop(
    "More than one cell population was provided. ",
    "cellPopulation must be length 1. To run over multiple cell types, ",
    "run combineSampleTileMatrix() to produce a new combined TSAM_Object and set ",
    "cellPopulation = 'counts'."
  )
  } else if (
    (!cellPopulation %in% names(SummarizedExperiment::assays(atacSE)) |
      !cellPopulation %in% names(SummarizedExperiment::assays(rnaSE)))
  ) {
    stop("cellPopulation was not found within atacSE and/or rnaSE.")
  } else if(cellPopulation == 'counts'){
    newatacSE <- atacSE
    newrnaSE <- rnaSE
    
  }else{

    newatacSE <- MOCHA::combineSampleTileMatrix(MOCHA::subsetMOCHAObject(atacSE, subsetBy = 'celltype', groupList = cellPopulation, subsetPeaks = TRUE))
    newrnaSE <- flattenChAI(rnaSE, cellPopulations = cellPopulation)
      
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newrnaSE <- newrnaSE[rownames(newrnaSE)  %in% geneList, ]
      
  if(!all(tileList %in% rownames(newatacSE)) & !is.null(tileList)){
     stop('tileList not found within atacSE.  Please read check that your tiles of interest are present in atacSE.')
  }else if(is.null(tileList)){
    tileGR <- SummarizedExperiment::rowRanges(newatacSE)
  }else{
    tileGR <- MOCHA::StringsToGRanges(tileList)
  }

  #Find all tiles within the given distance of the gene list of interest
  geneGR <- SummarizedExperiment::rowRanges(newrnaSE)

  geneTSS <- GenomicRanges::promoters(geneGR,upstream=1, downstream=1)
  geneWindows <- plyranges::stretch(geneTSS, distance*2)

  #Use join_overlap_intersect to find all tiles that overlap with the distance around the TSS. 
  tileGR <- suppressWarnings(plyranges::join_overlap_intersect(tileGR, geneWindows))

  #Generate the filtered tile list for those tiles that fall within the distance to the gene. 
  tileList <- MOCHA::GRangesToString(tileGR)

  #Generate the data frame of all combinations
  allCombos <- data.frame('Var1' = tileGR$GeneSymbol, 'Var2' = tileList)

  newatacSE <- newatacSE[rownames(newatacSE)  %in% tileList, ]

  #Test whether the continuousFormula is in the right format
  if(!(all.vars(stats::as.formula(continuousFormula))[1] =='exp1' & any(all.vars(stats::as.formula(continuousFormula)) %in% 'exp2'))){
    stop('continuousFormula is not in the correct format. Data from rnaSE will be used to predict atacSE, because atacSE is more complicated to model. Please format continuousFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect.')
  }

  if((any(all.vars(stats::as.formula(ziFormula)) %in% 'exp1'))){
    stop('ziFormula is not in the correct format. exp1 represents atac data and should not be in the ziformula. Please format ziFormula as  ~ Factor1 + Factor2 + exp2. This is also optional and can be set to ~0 for non-zero-inflated modeling. ')
  }


  if (zi_threshold < 0 | zi_threshold > 1 | ! is.numeric(zi_threshold)) {
    stop("zi_threshold must be between 0 and 1.")
  }

  modelList <- .pilotAssociations(SE1 = newatacSE, SE2 = newrnaSE,
                        allCombos = allCombos, sampleColumn = sampleColumn,
                        continuousFormula = continuousFormula,
                        modality = 'GeneTile',
                        ziFormula = ziFormula,
                        zi_threshold = zi_threshold,
                        family = stats::gaussian(),
                        samplingNumber = samplingNumber,
                        numCores = numCores
                        )
  return(modelList)

}


#' @title Test formulas for modeling tile accessibility as a function of another modality's feature counts.
#'
#' @description \code{pilot_scATAC_Associations} Function for testing formulas for zero-inflated modeling of
#'                   tile accessibility as a function of features from a General Modality.
#'                   Runs a given formula on a subset of the data, and returns the model results. 
#'                   This is meant to help during the model selection process. 
#'                   The General modality should be roughly normally distributed. \code{\link[glmmTMB]{glmmTMB}}. 
#'
#' @param atacSE A MOCHA Tile-by-Sample Object (SummarizedExperiment)generated from getSampleTileMatrix within \code{\link[MOCHA]{MOCHA}}. 
#' @param cellPopulation Name of a cell type within the TSAM_Object
#' @param generalSE A ChAI General modalityobject, generated by \code{makeChromVAR} or \code{importGeneralModality}
#' @param generalAssay Name of the assay within generalSE that should be used. 
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from generalSE and atacSE. This is used for aligning generalSE and atacSE.
#' @param continuousFormula The formula for the continuous data that should be used within glmmTMB. It should be in the
#'   format (exp ~ factors). All factors must be found in column names
#'   of the TSAM_Object metadata, except for CellType, FragNumber and CellCount, which will be extracted from the atacSE.
#'   modelFormula must start with 'exp' as the response.
#'   See \link[glmmTMB]{glmmTMB}.
#' @param ziFormula The formula for the zero-inflated data that should be used within glmmTMB. It should be in the
#'   format ( ~ factors). All factors must be found in column names
#'   of the atacSE colData metadata, except for CellType, FragNumber and CellCount, which will be extracted from the TSAM_Object.
#'   FragNumber and CellCounts will be log10 normalized within the function. 
#' @param zi_threshold Zero-inflated threshold ( range = 0-1), representing the fraction of samples with zeros. At or above this threshold, the zero-inflated modeling kicks in.
#' @param tileList A list of tiles, as strings in the format 'ChrX:1000-1499' to use. All tiles in this list will be tested for association with all measurements within generalList.
#' @param generalList A list of measurements from generalSE to associate with all tiles in the tileList.
#' @param samplingNumber An integer or a list of pairs (e.g. Protein1_TranscriptionFactor1). If an integer, it will randomly pull that many pairs from all possible combinations of sig1 and sig2, returning the model outputs. 
#'    If a list of pairs is provided as a list of strings, it will only test those. These pairs should be a subset of all possible pairs of sig1 and sig2.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 2.
#'
#' @return A named list of model outputs
#'
#'
#'
#' @examples
#' \dontrun{

#' }
#'
#' @export
#' @keywords pilot_associations
#'

pilot_scATAC_Associations <- function(atacSE, cellPopulation, 
                        generalSE, generalAssay,
                        sampleColumn, 
                        continuousFormula, 
                        ziFormula = ~ 0 + FragNumber, 
                        zi_threshold = 0,
                        tileList,
                        generalList, 
                        samplingNumber = 5,
                        numCores = 2) {

  if (!requireNamespace("MOCHA", quietly = TRUE)) {
      stop(
      "Package 'MOCHA' is required for pilot_scATAC_Associations. ",
      "Please install 'MOCHA' to proceed."
      )
  }

  if(isChAIObject(atacSE, type = 'data', returnType = TRUE) != 'scATAC'){

    stop('atacSE is not a SampleTileMatrix Object from MOCHA.')

  }

  if(!isChAIObject(generalSE, type = 'data', returnType = TRUE) %in% c('General', 'ChromVAR')){

    stop('generalSE is neither a ChAI General Modality Object, generated via importGeneralModality, 
            nor a ChAI ChromVAR object generated by makeChromVAR.')

  }
 
  if(!sampleColumn %in% colnames(SummarizedExperiment::colData(atacSE)) |
          !sampleColumn %in% colnames(SummarizedExperiment::colData(generalSE))){

    stop('sampleColumn missing from atacSE and/or generalSE.')
  }

  #Check whether samples align.     
  if(!all(atacSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]) |
      !all(generalSE@colData[,sampleColumn] %in% atacSE@colData[,sampleColumn])) {
 
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in generalSE and atacSE via ${sampleColumn}.'))
 
  }else if(!all(atacSE@colData[,sampleColumn] == generalSE@colData[,sampleColumn])){

      warning('Reording generalSE sample names to match atacSE.')
      generalSE <- generalSE[,order(generalSE@colData[,sampleColumn])]
      atacSE <- atacSE[,order(atacSE@colData[,sampleColumn])]
  }

  if(any(c(colnames(SummarizedExperiment::colData(atacSE)), 
      colnames(SummarizedExperiment::colData(generalSE))) %in% c('exp1','exp2'))){

    stop('metadata of atacSE and/or generalSE contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from atacSE and generalSE, not the metadata.
    Please remove these and try again.')

  }

   #Test whether tileList and geneList are found in their assays.
  if(!all(generalList %in% rownames(generalSE))){
     stop('generalList not found within generalSE. Please read check that your genes of interest are present in generalSE.')
  }
    
  if (methods::is(continuousFormula, 'character')) {
    continuousFormula <- stats::as.formula(continuousFormula)
  }

  if (methods::is(ziFormula,'character')) {
    ziFormula <- stats::as.formula(ziFormula)
  }

  #Subset down to one cell type
  if (length(cellPopulation) > 1) {
  stop(
    "More than one cell population was provided. ",
    "cellPopulation must be length 1. To run over multiple cell types, ",
    "run combineSampleTileMatrix() to produce a new combined TSAM_Object and set ",
    "cellPopulation = 'counts'."
  )
  } else if (!cellPopulation %in% names(SummarizedExperiment::assays(atacSE))){
    stop(stringr::str_interp("!{cellPopulation} was not found within atacSE."))
  } else if ( !generalAssay %in% names(SummarizedExperiment::assays(generalSE))){
     stop(stringr::str_interp("!{generalAssay} was not found within generalSE."))

  } else if(cellPopulation == 'counts'){
    newatacSE <- atacSE
    
  }else{
    newatacSE <- MOCHA::combineSampleTileMatrix(MOCHA::subsetMOCHAObject(atacSE, subsetBy = 'celltype', groupList = cellPopulation, subsetPeaks = TRUE))
   
  }
  newGeneral <- generalSE
  SummarizedExperiment::assays(newGeneral) <- SummarizedExperiment::assays(newGeneral)[generalAssay]

  if(!all(tileList %in% rownames(newatacSE))){
     stop('tileList not found within atacSE.  Please read check that your tiles of interest are present in atacSE.')
  }


  #Test whether the continuousFormula is in the right format
  if(!(all.vars(stats::as.formula(continuousFormula))[1] =='exp1' & any(all.vars(stats::as.formula(continuousFormula)) %in% 'exp2'))){
    stop('continuousFormula is not in the correct format. Data from generalSE will be used to predict atacSE, because atacSE is more complicated to model. Please format continuousFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect.')
  }

  if((any(all.vars(ziFormula) %in% 'exp1'))){
    stop('ziFormula is not in the correct format. exp1 represents atac data and should not be in the ziformula. Please format ziFormula as  ~ Factor1 + Factor2 + exp2. This is also optional and can be set to ~0 for non-zero-inflated modeling. ')
  }


  if (zi_threshold < 0 | zi_threshold > 1 | !is.numeric(zi_threshold)) {
    stop("zi_threshold must be between 0 and 1.")
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newatacSE <- newatacSE[rownames(newatacSE)  %in% tileList, ]
  newGeneral <- newGeneral[rownames(newGeneral)  %in% generalList, ]


  #Find all combinations of tileList and geneList to test. 
  cl <- parallel::makeCluster(numCores)


  #Find all combinations of tileList and geneList to test. 
  allCombos <- do.call('rbind', pbapply::pblapply(cl = cl, X = generalList,
                                                  findCombo, List2 = tileList))



  parallel::stopCluster(cl)
  
  modelList <- .pilotAssociations(SE1 = newatacSE, SE2 = newGeneral,
                        allCombos = allCombos, sampleColumn = sampleColumn,
                        modality = 'scATAC_Associations',
                        continuousFormula = continuousFormula,
                        ziFormula = ziFormula,
                        zi_threshold = zi_threshold,
                        family = stats::gaussian(),
                        samplingNumber = samplingNumber,
                        numCores = numCores
                        )

  return(modelList)

}



#' @title Test formulas for modeling gene expression as a funciton of another modality's feature counts.
#'
#' @description \code{pilot_scRNA_Associations} Function for testing formulas for zero-inflated modeling of gene expression as a function of features from a General Modality. 
#'              Runs a given formula on a subset of the data, and returns the model results. 
#'                This is meant to help during the model selection process. 
#'                 The General modality should be roughly normally distributed. \code{\link[glmmTMB]{glmmTMB}}. 
#' @param rnaSE A ChAI scRNA object (SummarizedExperiment object) generated by \code{makePseudobulkRNA}
#' @param cellPopulation - name of the assay (cell population) to extract and use from rnaSE 
#' @param generalSE A ChAI General modalityobject, generated by \code{makeChromVAR} or \code{importGeneralModality}
#' @param generalAssay Name of the assay from generalSE that you wish to use for modeling.
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from generalSE and rnaSE. This is used for aligning generalSE and rnaSE
#' @param modelFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect), where 
#'          exp1 is the dummy variable for gene expression and exp2 is the dummy variable for the rownames from generalSE. 
#' @param ziFormula A formula for zero inflation. By default, zero-inflated modeling is turned off by setting ziFormula = ~ 0
#' @param family String. Can be 'negativeBinomial1', 'negativeBinomial2', or 'poisson'. Default is "negativeBinomial2". 
#' @param geneList a list of genes from rnaSE to test. 
#' @param generalList A list of which rownames of generalAssay should be used for modeling associations. 
#' @param samplingNumber An integer or a list of pairs (e.g. Protein1_TranscriptionFactor1). If an integer, it will randomly pull that many pairs from all possible combinations of sig1 and sig2, returning the model outputs. 
#'    If a list of pairs is provided as a list of strings, it will only test those. These pairs should be a subset of all possible pairs of sig1 and sig2.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 2.
#'
#' @return A named list of model outputs
#'
#'
#' @examples
#' \dontrun{
#'   modelList <- pilot_scRNA(scRNA_Object, 
#'                            'CD16 Mono',
#'                            exp~ Age + Sex + days_since_symptoms + (1|PTID),
#'                              verbose = TRUE )
#' }
#'
#' @export
#' @keywords pilot_associations

pilot_scRNA_Associations <- function(rnaSE, cellPopulation, 
                                    generalSE, generalAssay,
                                    sampleColumn, 
                                    modelFormula, 
                                     ziFormula = ~0,
                                    cellCountThreshold = 10,
                                    family = "negativeBinomial2",
                                    geneList, 
                                    generalList = NULL,
                                    samplingNumber = 5,
                                    numCores = 10) {

if(isChAIObject(rnaSE, type = 'data', returnType = TRUE) != 'scRNA'){

    stop('rnaSE is not a ChAI scRNA Object.')

 }

if(!isChAIObject(generalSE, type = 'data', returnType = TRUE) %in% c('General', 'ChromVAR')){

    stop('generalSE is neither a ChAI General Modality Object, generated via importGeneralModality, 
            nor a ChAI ChromVAR object generated by makeChromVAR.')

}

 if(!sampleColumn %in% colnames(SummarizedExperiment::colData(generalSE)) |
          !sampleColumn %in% colnames(SummarizedExperiment::colData(rnaSE))){

    stop('sampleColumn missing from generalSE and/or rnaSE.')
  }

  #Check whether samples align.     
  if(!all(generalSE@colData[,sampleColumn] %in% rnaSE@colData[,sampleColumn]) |
            !all(rnaSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn])){
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in generalSE and rnaSE via ${sampleColumn}.'))
  }else if(!all(generalSE@colData[,sampleColumn] == rnaSE@colData[,sampleColumn])){
      warning('Reording rnaSE and generalSE to match.')
      rnaSE <- rnaSE[,order(rnaSE@colData[,sampleColumn])]
      generalSE <- generalSE[,order(generalSE@colData[,sampleColumn])]
  }

  if(any(c(colnames(SummarizedExperiment::colData(generalSE)), 
      colnames(SummarizedExperiment::colData(rnaSE))) %in% c('exp1','exp2'))){

    stop('metadata of generalSE and/or rnaSE contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from generalSE and rnaSE, not the metadata.
    Please remove these and try again.')

  }

   #Test whether tileList and geneList are found in their assays.
  if(!all(geneList %in% rownames(rnaSE))){
     stop('geneList not found within rnaSE. Please read check that your genes of interest are present in rnaSE.')
  }
  if(!all(generalList %in% rownames(generalSE))){
     stop('generalList not found within generalSE. Please double check generalList and generalSE rownames.')
  }
    
  if(tolower(family) == 'negativebinomial2'){ 
    family = glmmTMB::nbinom2()
  }else if(tolower(family)== 'negativebinomial1'){
    family = glmmTMB::nbinom1()
  }else if(tolower(family) == 'poisson'){
    family = stats::poisson()
  }else{
    stop('family not recognized.')
  }
      
     
  if (!methods::is(ziFormula,'formula')) {
    stop("ziFormula was not provided as a formula.")
  }

  if (zi_threshold < 0 | zi_threshold > 1 | ! is.numeric(zi_threshold)) {
    stop("zi_threshold must be between 0 and 1.")
  }
    
  if (methods::is(modelFormula, 'character')) {
    modelFormula <- stats::as.formula(modelFormula)
  }else if(!methods::is(modelFormula, 'formula')){
    stop('modelFormula is neither a string describing a formula, nor a formula itself. Please provide one of these formats.')
  }

  #Subset down to one cell type
  if (length(cellPopulation) > 1) {
  stop(
    "More than one cell population was provided. ",
    "cellPopulation must be length 1. To run over multiple cell types, ",
    "run combineSampleTileMatrix() to produce a new combined TSAM_Object and set ",
    "cellPopulation = 'counts'."
  )
  } else if (
    (!generalAssay %in% names(SummarizedExperiment::assays(generalSE)) |
      !cellPopulation %in% names(SummarizedExperiment::assays(rnaSE)))
  ) {
    stop("cellPopulation was not found within rnaSE and/or generalAssay within generalSE.")
  } else if(cellPopulation == 'counts'){
    newrnaSE <- rnaSE
    
    
  }else{
    newrnaSE <- flattenChAI(rnaSE, cellPopulations = cellPopulation)
  }

  newGeneral <- generalSE
  SummarizedExperiment::assays(newGeneral) <- SummarizedExperiment::assays(newGeneral)[generalAssay]

  if(sum(newrnaSE$CellCounts >=  cellCountThreshold) < 3){

      stop('Fewer than 3 samples passed the CellCounts threshold. Modeling not possible.')

  }else if(any(!newrnaSE$CellCounts >=  cellCountThreshold)){

      ## Filter both modalities down to samples with enough cells for modeling. 
      message(stringr::str_interp('${sum(!newrnaSE$CellCounts >=  cellCountThreshold)} Samples removed due to cell counts below cellCountThreshold'))
      newGeneral <- newGeneral[,newrnaSE$CellCounts >=  cellCountThreshold]
      newrnaSE <- newrnaSE[,newrnaSE$CellCounts >=  cellCountThreshold]
      
  }
    
      

  #Test whether the continuousFormula is in the right format
  if(!(all.vars(stats::as.formula(modelFormula))[1] =='exp1' & any(all.vars(stats::as.formula(modelFormula)) %in% 'exp2'))){
    stop('continuousFormula is not in the correct format. Data from rnaSE will be used to predict atacSE, because atacSE is more complicated to model. Please format continuousFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect.')
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newGeneral <- newGeneral[rownames(newGeneral)  %in% generalList, ]
  newrnaSE <- newrnaSE[rownames(newrnaSE)  %in% geneList, ]


  #Find all combinations of tileList and geneList to test. 
  allCombos <- as.data.frame(expand.grid(as.character(generalList),as.character(geneList)), stringsAsFactors = FALSE)

  modelList <- .pilotAssociations(SE1 = newrnaSE, SE2 = newGeneral,
                        allCombos = allCombos, sampleColumn = sampleColumn,
                        modality = 'scRNA_Associations',
                        continuousFormula = modelFormula,
                        ziFormula = ziFormula,
                        zi_threshold = 0,
                        family = family,
                        samplingNumber = samplingNumber,
                        numCores = numCores
                        )
  return(modelList)

}

#' @title Test formulas for modeling motif score as a function of another modality's feature counts.
#'
#' @description \code{pilot_ChromVAR_Associations}  Function for testing formulas for modeling of ChromVAR Motif scores as a function of features from a General Modality. 
#'              Runs a given formula on a subset of the data, and returns the model results. 
#'                This is meant to help during the model selection process. 
#'                 The General modality should be roughly normally distributed. \code{\link[glmmTMB]{glmmTMB}}. 
#' @param chromSE A ChAI ChromVAR object (SummarizedExperiment object) from \code{makeChromVAR}
#' @param cellPopulation - name of the assay (cell population) to extract and use from rnaSE 
#' @param generalSE A ChAI General modalityobject, generated by\code{importGeneralModality}
#' @param generalAssay Name of the assay from generalSE that you wish to use for modeling.
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from generalSE and rnaSE. This is used for aligning generalSE and rnaSE
#' @param modelFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect), where 
#'          exp1 is the dummy variable for gene expression and exp2 is the dummy variable for the rownames from generalSE. 
#' @param family String. Can be 'negativeBinomial1', 'negativeBinomial2', or 'poisson'. Default is 'poisson', which handles the zeros best. 
#' @param motifList a list of motifs from chromSE to test
#' @param generalList A list of which rownames of generalAssay should be used for modeling associations. 
#' @param samplingNumber An integer or a list of pairs (e.g. Protein1_TranscriptionFactor1). If an integer, it will randomly pull that many pairs from all possible combinations of sig1 and sig2, returning the model outputs. 
#'    If a list of pairs is provided as a list of strings, it will only test those. These pairs should be a subset of all possible pairs of sig1 and sig2.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 2.
#'
#' @return A named list of model outputs
#'
#'
#' @examples
#' \dontrun{
#'   modelList <- pilot_ChromVAR_Associations(ChromVAR_Object, 
#'                            'CD16 Mono',
#'                            exp~ Age + Sex + days_since_symptoms + (1|PTID),
#'                              verbose = TRUE )
#' }
#'
#' @export
#' @keywords pilot_associations
#'

pilot_ChromVAR_Associations <- function(chromSE, cellPopulation, 
                                    generalSE, generalAssay,
                                    sampleColumn, 
                                    modelFormula, 
                                    motifList, 
                                    generalList = NULL,
                                    samplingNumber = 5,
                                    numCores = 10) {

if(isChAIObject(chromSE, type = 'data', returnType = TRUE) != 'ChromVAR'){

    stop('chromSE is not a ChAI ChromVAR Object.')

 }

if(! isChAIObject(generalSE, type = 'data', returnType = TRUE) %in% c('General', 'ChromVAR')){

    stop('generalSE is neither a ChAI General Modality Object, generated via importGeneralModality, 
            nor a ChAI ChromVAR object generated by makeChromVAR.')

}

 if(!sampleColumn %in% colnames(SummarizedExperiment::colData(generalSE)) |
          !sampleColumn %in% colnames(SummarizedExperiment::colData(chromSE))){

    stop('sampleColumn missing from generalSE and/or chromSE.')
  }

  #Check whether samples align.     
  if(!all(generalSE@colData[,sampleColumn] %in% chromSE@colData[,sampleColumn]) |
            !all(chromSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn])){
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in generalSE and chromSE via ${sampleColumn}.'))
  }else if(!all(generalSE@colData[,sampleColumn] == chromSE@colData[,sampleColumn])){
      warning('Reording chromSE and generalSE to match.')
      chromSE <- chromSE[,order(chromSE@colData[,sampleColumn])]
      generalSE <- generalSE[,order(generalSE@colData[,sampleColumn])]
  }

  if(any(c(colnames(SummarizedExperiment::colData(generalSE)), 
      colnames(SummarizedExperiment::colData(chromSE))) %in% c('exp1','exp2'))){

    stop('metadata of generalSE and/or chromSE contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from generalSE and chromSE, not the metadata.
    Please remove these and try again.')

  }

   #Test whether tileList and motifList are found in their assays.
  if(!all(motifList %in% rownames(chromSE))){
     stop('motifList not found within chromSE. Please read check that your genes of interest are present in chromSE.')
  }
  if(!all(generalList %in% rownames(generalSE))){
     stop('generalList not found within generalSE. Please double check generalList and generalSE rownames.')
  }
    
  if (methods::is(modelFormula, 'character')) {
    modelFormula <- stats::as.formula(modelFormula)
  }else if(!methods::is(modelFormula, 'formula')){
    stop('modelFormula is neither a string describing a formula, nor a formula itself. Please provide one of these formats.')
  }

  #Subset down to one cell type
  if (length(cellPopulation) > 1) {
  stop(
    "More than one cell population was provided. ",
    "cellPopulation must be length 1. To run over multiple cell types, ",
    "run combineSampleTileMatrix() to produce a new combined TSAM_Object and set ",
    "cellPopulation = 'counts'."
  )
  } else if (
    (!generalAssay %in% names(SummarizedExperiment::assays(generalSE)) |
      !cellPopulation %in% names(SummarizedExperiment::assays(chromSE)))
  ) {
    stop("cellPopulation was not found within chromSE and/or generalAssay within generalSE.")
  } else if(cellPopulation == 'counts'){
    newchromSE <- chromSE
    
    
  }else{
    newchromSE <- flattenChAI(chromSE, cellPopulations = cellPopulation)
  }

  newGeneral <- generalSE
  SummarizedExperiment::assays(newGeneral) <- SummarizedExperiment::assays(newGeneral)[generalAssay]


  #Test whether the continuousFormula is in the right format
  if(!(all.vars(stats::as.formula(modelFormula))[1] =='exp1' & any(all.vars(stats::as.formula(modelFormula)) %in% 'exp2'))){
    stop('continuousFormula is not in the correct format. Data from chromSE will be used to predict atacSE, because atacSE is more complicated to model. Please format continuousFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect.')
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newGeneral <- newGeneral[rownames(newGeneral)  %in% generalList, ]
  newchromSE <- newchromSE[rownames(newchromSE)  %in% motifList, ]


  #Find all combinations of tileList and motifList to test. 
  allCombos <- as.data.frame(expand.grid(as.character(generalList),as.character(motifList)), stringsAsFactors = FALSE)

  modelList <- .pilotAssociations(SE1 = newchromSE, SE2 = newGeneral,
                        allCombos = allCombos, sampleColumn = sampleColumn,
                        modality = 'ChromVAR_Associations',
                        continuousFormula = modelFormula,
                        ziFormula = ~0,
                        zi_threshold = 0,
                        family = family,
                        samplingNumber = samplingNumber,
                        numCores = numCores
                        )
  return(modelList)

}







#' @title Test formulas for modeling one modality's feature counts as a function of another modality's feature counts (Generalized)
#'
#' @description \code{pilot_General_Associations} Function for testing formulas for zero-inflated or standard GLM modeling of
#'                   one modality's feature counts as a function of another modality's feature counts. 
#'                   Runs a given formula on a subset of the data, and returns the model results. 
#'                   This is meant to help during the model selection process. 
#'                   The second general modality should be roughly normally distributed. \code{\link[glmmTMB]{glmmTMB}}. 
#' @param SE1 SummarizedExperiment object for measurement-type 1 from \code{importGeneralModality}
#' @param SE2 SummarizedExperiment object for measurement-type 2 from  \code{makeChromVAR} or \code{importGeneralModality}
#' @param assay1 - name of the assay to extract and use from SE1
#' @param assay2 - name of the assay to extract and use from SE2
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from SE1 and SE2. This is used for aligning SE1 and SE2
#' @param modelFormula Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect)
#' @param ziFormula A formula for zero inflation. By default, zero-inflated modeling is turned off by setting ziFormula = ~ 0
#' @param sig1 A list of rows from SE1 to test. 
#' @param sig2 A list of rows from SE2 to test. 
#' @param family distribution family parameter, passed to glmmTMB to describe the data's distribution.
#'     Default is normal (gaussian()). See  \link[glmmTMB]{glmmTMB}.
#' @param samplingNumber An integer or a list of pairs (e.g. Protein1_TranscriptionFactor1). If an integer, it will randomly pull that many pairs from all possible combinations of sig1 and sig2, returning the model outputs. 
#'    If a list of pairs is provided as a list of strings, it will only test those. These pairs should be a subset of all possible pairs of sig1 and sig2.
#' @param numCores  Number of cores for glmmTMB to parallelize over. 
#' @return A named list of model outputs
#'
#'
#' @export
#' @keywords pilot_associations

pilot_General_Associations <- function(SE1, SE2, assay1, assay2, sampleColumn, 
                                        modelFormula, ziFormula = ~ 0,
                                       sig1, sig2, family = stats::gaussian(),
                                        numCores = 2, samplingNumber = 5) {

  if(isChAIObject(SE1, type = 'data', returnType = TRUE) != 'General' & 
      ! isChAIObject(SE2, type = 'data', returnType = TRUE) %in% c('General', 'ChromVAR')){

    stop('SE1 or SE2 is not a ChAI General Modality Object, generated via importGeneralModality.')
  }
                                   

   #Check whether samples align.     
  if(!all(SE1@colData[,sampleColumn] %in% SE2@colData[,sampleColumn]) | 
          !all(SE2@colData[,sampleColumn] %in% SE1@colData[,sampleColumn])) {
       stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in SE1 and SE2 via ${sampleColumn}.'))
  }else if(!all(SE1@colData[,sampleColumn] == SE2@colData[,sampleColumn])){
      warning('Reording SE1 and SE2 to match.')
      SE1 <- SE1[,order(SE1@colData[,sampleColumn])]
      SE2 <- SE2[,order(SE2@colData[,sampleColumn])]
  }

  if(any(c(colnames(SummarizedExperiment::colData(SE1)), 
      colnames(SummarizedExperiment::colData(SE2))) %in% c('exp1','exp2'))){

    stop('metadata of SE1 and/or SE2 contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from SE1 and SE2, not the metadata.
    Please remove these and try again.')

  }
      
  if (!methods::is(ziFormula,'formula')) {
         stop("ziFormula was not provided as a formula.")
  }

 
  if(!all(sig2 %in% rownames(SE2))){
     stop('sig2 not found within SE2. Please read documentation.')
  }
    
  #Test whether sig1 and sig2 are found in their assays.
  if(!all(sig1 %in% rownames(SE1))){
     stop('sig1 not found within SE1. Please read documentation.')
  }

  #Test whether the formula is in the right format
  if(!(all.vars(stats::as.formula(modelFormula))[1] =='exp1' & any(all.vars(stats::as.formula(modelFormula)) %in% 'exp2'))){
    stop('modelFormula is not in the correct format. Data from SE2 will be used to predict SE1. Please format modelFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect.')
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newSE1 <- SE1[rownames(SE1)  %in% sig1, ]
  newSE2 <- SE2[rownames(SE2)  %in% sig2, ]
  SummarizedExperiment::assays(newSE1) <- SummarizedExperiment::assays(newSE1)[assay1]
  SummarizedExperiment::assays(newSE2) <- SummarizedExperiment::assays(newSE2)[assay2]

  #Find all combinations of sig1 and sig2 to test. 
  allCombos <- as.data.frame(expand.grid(as.character(sig2),as.character(sig1)), stringsAsFactors = FALSE)

  modelList <- .pilotAssociations(SE1 = newSE1, SE2 = newSE2,
                        allCombos = allCombos, sampleColumn = sampleColumn,
                        modality = 'General_Assocations',
                        continuousFormula = modelFormula,
                        ziFormula = ~0,
                        zi_threshold = 0,
                        family = family,
                        samplingNumber = samplingNumber,
                        numCores = numCores
                        )
  return(modelList)

}



#' @title pilotAssociations
#'
#' @description \code{pilotAssociations} Internal generic function for testing associations between modalities. 
#' @param SE_Object A SummarizedExperiment object generated from
#' @param continuousFormula The formula for the continuous data that should be used within glmmTMB. It should be in the
#'   format (exp ~ factors). All factors must be found in column names of the SE_Object colData (i.e. sample metadata).
#'   See \link[glmmTMB]{glmmTMB}.
#' @param  ziFormula The formula for the zero-inflated data that should be used within glmmTMB. It should be in the
#'   format ( ~ factors). All factors must be found in column names
#'   of SE_Object colData (i.e. sample metadata).
#' @param family distribution family parameter, passed to glmmTMB to describe the data's distribution.
#'     Default is normal (gaussian()). See  \link[glmmTMB]{glmmTMB}.
#' @param zi_threshold Zero-inflated threshold ( range = 0-1), representing the fraction of samples with zeros.
#'           At or above this threshold, the zero-inflated modeling kicks in.
#' @param pilotIndices integer. Specific locations to test within the peakset of the cell type chosen. 
#' @param verbose Set TRUE to display additional messages. Default is FALSE.
#' @param numCores integer. Number of cores to parallelize across.
#'
#' @return a list of model objects from glmmTMB
#'
#' @noRd
#'
.pilotAssociations <- function(SE1, SE2, allCombos, sampleColumn, 
                        continuousFormula = NULL,
                        modality = 'General_Associations', 
                        ziFormula = NULL,
                        family = stats::gaussian(),
                        zi_threshold = 0,
                        samplingNumber,
                        numCores = 1) {

   if(any(dim(allCombos) ==0)){
    stop('No combinations found, so there is nothing to test for associations. Please check that the input lists are not empty.')
  }
  ## Extract matrices and metadata
  mat1 <- SummarizedExperiment::assays(SE1)[[1]]
  mat2 <- SummarizedExperiment::assays(SE2)[[1]]

  if(modality == 'scATAC_Associations'){
    mat1 <- log2(mat1 + 1)
  } else if(modality == 'GeneTile'){
    mat1 <- log2(mat1 + 1)
    mat2 <- log2(mat2 + 1)
  }

  metaData1 <- SummarizedExperiment::colData(SE1)
  metaData2 <- SummarizedExperiment::colData(SE2)

  unique2 <- colnames(metaData2)[!colnames(metaData2) %in% colnames(metaData1)]
  if(length(unique2) > 0){
    metaData <- dplyr::left_join(as.data.frame(metaData1), 
                as.data.frame(metaData2[,c(unique2, sampleColumn)]), by = sampleColumn)
  }else{
    metaData = metaData1
  }

 if (any(c('exp1','exp2') %in% colnames(metaData))) {
    stop("Variables for exp1 and exp2 are within the metaData.")
  }

  if (!methods::is(continuousFormula, "formula") ){
    stop("continuousFormula was not provided as a formula.")
  }
  if (!methods::is(ziFormula,"formula") & !is.null( ziFormula) ) {
    stop(" ziFormula was not provided as a formula.")
  }

  #Transform in character strings for multithreading. 
  continuousFormula <- deparse(continuousFormula)
  ziFormula <- deparse( ziFormula)

  if (!all(all.vars(continuousFormula) %in% c("exp1", "exp2", colnames(metaData)))) {
    stop("Model formula is not in the correct format (exp1 ~ factors) or model factors are not found in column names of metadata.")
  }

  if (!all(all.vars( ziFormula) %in% c( "exp2", colnames(metaData)))) {
    stop("factors from the  ziFormula were not found in the metadata.")
  }

  pairList <- paste(allCombos[,2], allCombos[,1], sep = "_")

  ## Log transform the FragmentNumbers so as to stabilize the model. But only if FragNumber is in the model. Same for CellCounts.
  if(any(colnames(metaData) %in% c('FragNumber'))){
    metaData$rawFragNumber = metaData$FragNumber
    metaData$FragNumber <- log10(metaData$FragNumber)
  }
  if(any(colnames(metaData) %in% c('CellCounts'))){
    metaData$rawCellCounts = metaData$CellCounts
    metaData$CellCounts <- log10(metaData$CellCounts)
  }


  if(length(samplingNumber) == 1 & is.numeric(samplingNumber)){
    
    pilotIndex = sample(1:dim(allCombos)[1], samplingNumber)
    pilotNames = pairList[pilotIndex]

  }else if(length(samplingNumber) > 1 & all(samplingNumber %in% pairList)){

    pilotIndex <- which(pairList %in% samplingNumber)
    pilotNames = pairList[pilotIndex]

  }else{
    stop('Incorrect samplingNumber. Please provide a single integer, or a specific list of pairs that are a subset of the data you want to test (format Modality1_Modality2)')
  }

    
  # convert allCombos into a list to iterate ove (need to reverse order for modeling, since expand grid tends to flip it.)
  allComboList <- lapply(pilotIndex, function(x){
                   rev(as.character(unlist(allCombos[x,])))
      }) 

  # Make your clusters for efficient parallelization
  modelList <- pbapply::pblapply(X = allComboList, function(x) {
  
    df <- data.frame(exp1 = unlist(mat1[x[1],]), 
              exp2 = unlist(mat2[x[2],]), 
              metaData, stringsAsFactors= FALSE)

    tryCatch({
        
    if(modality != 'scATAC_Associations' & all(ziFormula != ~ 0)){
         modelRes <- glmmTMB::glmmTMB(exp1 ~ 1,
          ziformula = ~ 0,
          data = df,
          family = family,
          REML = TRUE,
          control = glmmTMB::glmmTMBControl(parallel = numCores)
        )
        
        sigZI <- DHARMa::testZeroInflation(modelRes)$p.value < 0.05
          
      }else{
      
          sigZI = FALSE
          
      }
    
    if(modality != 'scATAC_Associations'){
        
        if(sigZI){
            suppressWarnings(modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula),
              ziformula = stats::as.formula(ziFormula),
              data = df,
              family = family,
              REML = TRUE,
              control = glmmTMB::glmmTMBControl(parallel = numCores)
             ))
            
        }else{
         suppressWarnings( modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula),
              ziformula = ~ 0,
              data = df,
              family = family,
              REML = TRUE,
              control = glmmTMB::glmmTMBControl(parallel = numCores)
            ))
         }
  
     }else if(sum(df$exp1 == 0, na.rm = TRUE)/length(df$exp1) == 0){
        modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula),
          ziformula = ~ 0,
          data = df,
          family = family,
          REML = TRUE,
          control = glmmTMB::glmmTMBControl(parallel = numCores)
        )
       
      }else if(sum(df$exp1 == 0, na.rm = TRUE)/length(df$exp1) <= zi_threshold){
        df$exp1[df$exp1 == 0] = NA
        modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula),
          ziformula = ~ 0,
          data = df,
          family = family,
          REML = TRUE,
          control = glmmTMB::glmmTMBControl(parallel = numCores)
        )
       
      }else {
        modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula),
          ziformula = stats::as.formula(ziFormula),
          data = df,
          family = family,
          REML = TRUE,
          control = glmmTMB::glmmTMBControl(parallel = numCores)
        )
      }
    }, error = function(e){
       list('error' = e, 'Measurement' = x, 'Data' = df)
    })

  }, cl = NULL)
  names(modelList) <- pilotNames

  return(modelList)
}


