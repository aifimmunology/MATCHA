              
#' @title Subset a ChAI object 
#'
#' @description \code{subsetChAI} Takes the output of makePseudobulkRNA, normalizedPseudobulk, makeChromVAR, or importGeneralModality

#'
#' @param ChAIObject  the output of makePseudobulkRNA or normalizePseudobulk
#' @param subsetBy A string that is either 'CellType', 'Assay', or the name of column that has sample names in the Seurat object's metadata 
#' @param groupList The list of cell types or samples that you want to keep. 
#' @return A SummarizedExperiment with only the cell types or samples of interest.
#'
#' @examples
#' \dontrun{
#'   chromSE2 <- subsetChAI(subChrom, subsetBy = 'COVID_status', 'Negative')
#' }
#'
#'
#' @keywords data_object_manipulation
#'
#' @export
#'

subsetChAI <- function(ChAIObject,
                              subsetBy,
                              groupList) {

       
    #identify which modality is in use. 
    dataType <- isChAIObject(ChAIObject, type = 'data', returnType = TRUE)
    
    if (!methods::is(ChAIObject, "SummarizedExperiment")) {
        stop('The ChAIObject that you provided is not a Summarized Experiment.')
    }

    if(!any(names(ChAIObject@metadata) %in% 'History')){
        stop('The ChAIObject you provided is not actually a ChAI Object. Make sure it was generated via MOCHA or ChAI. See tutorial or worflow diagrams on data import.')
    }

    if(dataType == 'scATAC'){

        stop('The ChAIObject you provided was generated by MOCHA. Please use subsetMOCHAObject to subset this object, instead of subsetChAI.')

    }

    if(dataType == 'model'){

        stop('The ChAIObject you provided was a ChAI Model object, containing model results. Please provide a ChAI Data object.')

    }

    if(any(grepl('flattenChAI',  unlist(ChAIObject@metadata$History)))){

        stop("The ChAIObject you provided has been run through flattenChAI, and this function is not needd for subsetting. Please use standard data.frame-like subsetting operations instead (i.e. ChAIObj[C('GeneA','GeneB'), ChAIObject$Status %in% 'Healthy'])")

    }
     
    sampleData <- SummarizedExperiment::colData(ChAIObject)
    
    if (grepl("celltype|assay", tolower(subsetBy))) {
        if(all(groupList %in% names(SummarizedExperiment::assays(ChAIObject)))){
            newSE <- ChAIObject
            SummarizedExperiment::assays(newSE) <- SummarizedExperiment::assays(newSE)[groupList]
            if(dataType == 'scRNA'){
                newSE@metadata$summarizedData <- newSE@metadata$summarizedData[groupList,]
                SummarizedExperiment::assays(newSE@metadata$detectionRates) <- SummarizedExperiment::assays(newSE@metadata$detectionRates)[groupList]
            }else if(dataType == 'ChromVAR'){
                newSE@metadata$summarizedData <- newSE@metadata$summarizedData[groupList,]
            }
            
        }else{
            stop('You asked to subset by cell type, but the provided list of cell types (groupList) includes some or all that are not found within ChAIObject.')
        }

    }else if (subsetBy %in% colnames(sampleData)) {
        if(all(groupList %in% unique(sampleData[,subsetBy]))){
            newSE <- ChAIObject
            newSE <- newSE[,sampleData[[subsetBy]] %in% groupList]
            if(dataType == 'scRNA'){
                newSE@metadata$summarizedData <- newSE@metadata$summarizedData[,sampleData[[subsetBy]] %in% groupList]
                newSE@metadata$detectionRates <- newSE@metadata$detectionRates[,sampleData[[subsetBy]] %in% groupList]
            }else if(dataType == 'ChromVAR'){
                newSE@metadata$summarizedData <- newSE@metadata$summarizedData[,sampleData[[subsetBy]] %in% groupList]
            }
        }else{
            stop('Some indices of groupList were not found within the metadata of column provided to subsetBy.')
        }
    }else{
    
        stop("The subsetBy variable is neither a column within the sample metadata, nor the string 'CellType'.",
             "Please provide one or the other")
        
    }
    return(newSE)
}

#' @title Flatten a ChAI object from multiple matrices into one large matrix
#'
#' @description \code{flattenChAI} Takes a ChAI Object (ChromVAR or scRNA) and combines the matrices across cell types, while pulling in associated metadata in summarizedData and/or detectionRates
#' @param ChAIObject  the output of makePseudobulkRNA/normalizePseudobulk or makeChromVAR
#' @param cellPopulations Cell populations to keep through the combining process. 
#' @param metadataT A flag for whether or not additional metadata is present. Should be set to FALSE. This should be removed in future versions. 
#' @return A SummarizedExperiment with one assay named 'counts' which contains all Sample and Cell type gene expression data.
#'              It also moves all the summarizedData into the colData slot of the SummarizedExperiment.
#'
#'
#' @keywords data_object_manipulation
#'
#' @export
#'
#

flattenChAI <- function(ChAIObject,
                              cellPopulations = 'All', metadataT = TRUE) {

    dataType <- isChAIObject(ChAIObject, type = 'data')
    CellType <- Sample <- NULL

    if(all(tolower(cellPopulations) == 'all')){
        subObject = ChAIObject
    }else{
        subObject <- subsetChAI(ChAIObject, subsetBy = 'celltype', groupList = cellPopulations)
    }

    summarizedData <- S4Vectors::metadata(subObject)$summarizedData
    sampleData <- SummarizedExperiment::colData(subObject)
    
    cellNames <- SummarizedExperiment::assays(subObject)
    # Let's generate a new assay, that will contain the
    # the intensity for a given cell, as well as the
    # median intensity per sample-tile for all other cell types (i.e. the background)

    newAssays <- list(do.call("cbind", methods::as(cellNames, "list")))
    newSamplesNames <- unlist(lapply(names(cellNames), function(x) {
        gsub(" ", "_", paste(x, colnames(subObject), sep = "__"))
    }))
    names(newAssays) <- "counts"
    colnames(newAssays[[1]]) <- newSamplesNames

    # Combine Sample and Cell type for the new columns.
    # This takes the colData and repeats it across cell types for a given sample
    # Rows are now CellType__Sample. So for example 'CD16 Mono' and 'Sample1' becomes "CD16_Mono__Sample1"
    allSampleData <- as.data.frame(do.call("rbind", lapply(names(cellNames), function(x) {
        tmp_meta <- sampleData
        tmp_meta$Sample <- gsub(" ", "_", paste(x, sampleData[['Sample']], sep = "__"))
        tmp_meta$CellType <- rep(x, dim(tmp_meta)[1])
        rownames(tmp_meta) <- tmp_meta$Sample
        tmp_meta
    })))

    ## Add flatten to object history
    History <- append(subObject@metadata$History, paste("flattenChAI", utils::packageVersion("ChAI")))

    if(metadataT & dataType != 'General'){

        summarizedData <- S4Vectors::metadata(subObject)$summarizedData
        addMetaData <- as.data.frame(do.call('cbind',lapply(SummarizedExperiment::assays(summarizedData),
                        function(x){
            tmpMeta <- x
            tmpMeta$CellType = rownames(x)
            tmpMeta2 <- tidyr::pivot_longer(
                tmpMeta,
                cols = colnames(x),
                names_to = "Sample",
                values_to = "Freq"
            )
            tmpMeta2 <- dplyr::mutate(
                tmpMeta2,
                Sample = gsub(" ", "_", paste(CellType, Sample, sep = "__"))
            )
            output <- unlist(tmpMeta2$Freq )
            names(output) <- tmpMeta2$Sample
            output
        })))
        addMetaData = addMetaData[, !colnames(addMetaData) %in% colnames(allSampleData)]
        addMetaData$Sample = rownames(addMetaData)
        fullMeta <- dplyr::full_join( as.data.frame(allSampleData), 
                                     as.data.frame(addMetaData), by = 'Sample')
        rownames(fullMeta) = fullMeta$Sample
        
         
        
        if(! all(fullMeta$Sample %in% colnames(newAssays[[1]]))){
            
            stop('Sample names are not aligned. Metadata appears to be corrupted. ')
            
        }
        
        #Must test if there are rowRanges, or else an error will be thrown. 
        if(!is.null(SummarizedExperiment::rowRanges(subObject))){
            newSE <- SummarizedExperiment::SummarizedExperiment(newAssays,
                    colData = fullMeta,
                    rowRanges = SummarizedExperiment::rowRanges(subObject),
                     metadata = list('History' = History))
        }else{
            newSE <- SummarizedExperiment::SummarizedExperiment(newAssays, 
                    colData = fullMeta,
                    rowData = SummarizedExperiment::rowData(subObject),
                    metadata = list('History' = History))
        }

    }else if(!is.null(SummarizedExperiment::rowRanges(subObject))){
        newSE <- SummarizedExperiment::SummarizedExperiment(newAssays,
                    colData = allSampleData,
                    rowRanges = SummarizedExperiment::rowRanges(subObject),
                    metadata = list('History' = History))
    }else if(!is.null(SummarizedExperiment::rowData(subObject))){
        newSE <- SummarizedExperiment::SummarizedExperiment(newAssays,
                    rowData = SummarizedExperiment::rowData(subObject),
                    colData = allSampleData,
                    metadata = list('History' = History))
    }else {
        newSE <- SummarizedExperiment::SummarizedExperiment(newAssays,
                    colData = allSampleData,
                    metadata = list('History' = History))
    }

  
    return(newSE)

}


#' @title Merge ChAI objects of similar data types into one.
#'
#' @description \code{mergeChAI} Takes the ChAI objects that are the same type (scRNA, ChromVAR, or general) and merges them. Allows for running data import in batches before merging.

#'
#' @param ChAIObjectList  A list of ChAI SummarizedExperiments, each one with the same history (i.e. all are makePseudobulkRNA, normalizePseudobulk, makeChromVAR, or importGeneralModality.
#' @return A ChAI object with all the samples combined (including any summarizedData and detectionRates, if necessary)
#'
#'
#' @keywords data_object_manipulation
#'
#' @export
#'
#

mergeChAI <- function(ChAIObjectList) {
    
    if (!methods::is(ChAIObjectList, "list")) {
        stop('ChAIObjectList is not a list.')
    }
    
    if (any(unlist(lapply(ChAIObjectList, function(X) !methods::is(X, "SummarizedExperiment"))))){
        
        stop('ChAIObjectList is not a list of SummarizedExperiments.')
    
    }

    #Check that history is the same. Merge History
    allHistory <- lapply(ChAIObjectList,  function(x) x@metadata$History)
    standardHistory <- length(allHistory[[1]])

    if(!all(lengths(allHistory) %in% standardHistory)){
        stop("SummarizedExperiments within your ChAIObjectList are different. Please check each object's history via ChAiObject@metadata$History, and do not combine these objects.")
    }

    # Check if it was the same function used. All the function calls should be the same, so running unique on them should yield a vector of the same length as standardHistory.
    functionUsed <- unlist(lapply(allHistory, function(x){
            tempList <- stringr::str_split(x, pattern = ' ')[[1]]
            unlist(lapply(tempList, function(y) y[[1]]))[1]
    }))

    if(length(unique(functionUsed)) != standardHistory){
        stop("SummarizedExperiments within your ChAIObjectList are different. Please check each object's history via ChAIObject@metadata$History, and do not combine these objects.")
    }
    #Repeat the same for ChAI version number. 
    VersionUsed <- unlist(lapply(allHistory, function(x){
            tempList <- stringr::str_split(x, pattern = ' ')[[1]]
            unlist(tempList[[2]])
    }))
    
    if(length(unique(VersionUsed)) != 1){
       warning('Objects were processed under different versions of ChAI. Be careful.')
    }

    #Merge History
    allHistory <- append(unique(allHistory), paste("mergeChAI", utils::packageVersion("ChAI")))       

    modalityTypes <- c('reformatChromVARList', 'makePseudobulkRNA', 'importGeneralModality','getSampleTileMatrix')        
    #identify which modality is in use. 
    specModality <- modalityTypes[which(unlist(lapply(modalityTypes, function(x) any(grepl(x,unlist(allHistory))))))]
                
    ## If celltypes/assays are in common, just merge those. 
    assayList <- lapply(ChAIObjectList, function(XX) names(SummarizedExperiment::assays(XX)))
                                                    
    if(any(table(unlist(assayList)) > 1)){
        
        if(!all(table(assayList) >1)){
        
            warning('At least one cell type/assay is the repeated across the objects in the ChAIObjectList. These common celltypes/assays will be merged, and cell types/Assays that are unique to one object will be dropped. If you want to avoid this behavior, provide a ChAIObjectList where celltypes/assays are unique to each object. ')
        }
        
        newSE <- SEtools::mergeSEs(ChAIObjectList, commonOnly = FALSE,
                               do.scale = FALSE, 
                               addDatasetPrefix = FALSE, defValues = NA)
        
    }else {
    
        newSE <- mergeUniqueAssays(ChAIObjectList, sampleColumn = 'Sample', fill = NA)
    
    }
                  
    if(specModality == 'makePseudobulkRNA'){

        #Merge summarizedData & DetectionRate info
        summarizedDataList <- lapply(ChAIObjectList, function(x) x@metadata$summarizedData)
        DetectionRateList <- lapply(ChAIObjectList, function(x) x@metadata$detectionRates)
                                    
        if(any(table(unlist(assayList)) > 1)){
                               
            newSummarizedData <- SEtools::mergeSEs(summarizedDataList,
                                        do.scale = FALSE, 
                                        addDatasetPrefix = FALSE, defValues = NA)
            newDetectionRate <- SEtools::mergeSEs(DetectionRateList,
                                        do.scale = FALSE, 
                                        addDatasetPrefix = FALSE, defValues = NA)
            
        }else{
        
            newSummarizedData <- mergeUniqueRows(summarizedDataList, newSE, fill = 0)
            newDetectionRate <- mergeUniqueAssays(DetectionRateList, sampleColumn = 'Sample', fill = 0)
        }

        newSE@metadata = list('summarizedData' = newSummarizedData, 'detectionRates' = newDetectionRate, 
                                'History' = allHistory)

    }else if(specModality == 'makeChromVAR'){

        
        summarizedDataList <- lapply(ChAIObjectList, function(x) x@metadata$summarizedData)

        #Merge summarizedData                                 
        if(any(table(unlist(assayList)) > 1)){
                               
            newSummarizedData <- SEtools::mergeSEs(summarizedDataList,
                                        do.scale = FALSE, 
                                        addDatasetPrefix = FALSE, defValues = NA)
        }else{
        
            newSummarizedData <- mergeUniqueRows(summarizedDataList, newSE, fill = 0)
            
        }

        newSE@metadata = list('summarizedData' = newSummarizedData,  'History' = allHistory)
    }else if(specModality == 'getSampleTileMatrix'){
        
        #Merge summarizedData
        summarizedDataList <- lapply(ChAIObjectList, function(x) x@metadata$summarizedData)

        if(any(table(unlist(assayList)) > 1)){
                               
            newSummarizedData <- SEtools::mergeSEs(summarizedDataList,
                                        do.scale = FALSE, 
                                        addDatasetPrefix = FALSE, defValues = NA)
        }else{
        
            newSummarizedData <- mergeUniqueRows(summarizedDataList, newSE, fill = 0)
            
        }

        ## Check that Genome and TxDb are all the same. 

        allGenomes <- unique(unlist(lapply(ChAIObjectList, function(X) X@metadata$Genome)))
        allTxDb <- unique(unlist(lapply(ChAIObjectList, function(X) X@metadata$TxDb$pkgname)))
        allOrgDb <- unique(unlist(lapply(ChAIObjectList, function(X) X@metadata$OrgDb$pkgname)))

        if(length(allGenomes) != 1){
            stop('These MOCHA objects were generated using different genomes and cannot be combined.')
        }else if(length(allTxDb ) != 1){
            stop('These MOCHA objects were generated using different Transcript databases and should not be combined. The tile annotations will not match.')
        }else if(length(allOrgDb ) != 1){
            stop('These MOCHA objects were generated using different Organism databases (OrgDb) and cannot be combined.')
        }

        warning('This function will not merge the MOCHA directories. You will not be able to plot regions with this object, only use it within ChAI for modeling.')

        newSE@metadata = list('summarizedData' = newSummarizedData, 
                            'Genome' = ,ChAIObjectList[[1]]@metadata$Genome,
                            'TxDb' = ChAIObjectList[[1]]@metadata$TxDb,
                            'OrgDb' = ChAIObjectList[[1]]@metadata$OrgDb,
                            'History' = allHistory)


    }else{

        #For importGeneralModality
        newSE@metadata = list('History' = allHistory)
        
    }

    return(newSE)
}

#' @title mergeUniqueAssays
#' @description \code{mergeUniqueAssays} Merge SummarizedExperiments with different assays and 
#'           partially overlapping sample names, based on the rownames of their colData
#' @param SEObjectList A list of SummarizedExperiments, all of the same class.
#' @param fill Default is NA. Fill for missing values/samples between objects
#' @return One SE object with all assays and samples
#' @noRd
                                         
mergeUniqueAssays <- function(SEObjectList, sampleColumn = 'Sample', fill = NA){
    
    ## Generate AssayList for new object
    assayList <- NULL
    
    for(i in SEObjectList){
    
        assayList <- append(assayList, SummarizedExperiment::assays(i))
        
    }
    
    ##Identify all sample names
    allSamples <- unique(unlist(lapply(SEObjectList,  function(XX)
                        rownames(SummarizedExperiment::colData(XX)))))
    allSamples <- allSamples[order(allSamples)]
                                
    ##Identify all rownames
    allFeatures <- unique(unlist(lapply(SEObjectList,  function(XX)
                        rownames(SummarizedExperiment::rowData(XX)))))
    allFeatures <- allFeatures[order(allFeatures)]
                                
    ## Fill in missing samples           
    assayList <- lapply(assayList, function(XX){

        #Fill in missing samples
        if(any(!allSamples %in% colnames(XX))){
            filled_data <- do.call('cbind', lapply(which(!allSamples %in% colnames(XX)), function(x){
                    rep(fill, dim(XX)[1])
            }))
            colnames(filled_data) <- allSamples[!allSamples %in% colnames(XX)]
            new_mat <- cbind(XX, filled_data)

        }else{
        
            new_mat <- XX
            
        }
        
        #Fill in missing features
        if(any(!allFeatures %in% rownames(new_mat))){
            filled_data <- do.call('rbind', lapply(which(!allFeatures %in% rownames(new_mat)), function(x){
                    rep(fill, dim(XX)[2])
            }))
            rownames(filled_data) <- allFeatures[!allFeatures %in% rownames(new_mat)]
            new_mat <- cbind(new_mat, filled_data)

        }
        
        new_mat <- new_mat[sort(rownames(new_mat)),sort(colnames(new_mat))]
    })
        
    #Set names correctly
    assayNames <- unlist(lapply(SEObjectList,  function(XX)
                        names(SummarizedExperiment::assays(XX))))
                                
    names(assayList) <- assayNames
                                
    ##Identify common metadata columns across samples                            
    allColumns <- unlist(lapply(SEObjectList,  function(XX)
                        colnames(SummarizedExperiment::colData(XX))))
    commonColumns <- names(table(allColumns)[table(allColumns) == max(table(allColumns))])
                                
    if(length(commonColumns) == 0){
    
        stop('Incorrect length')
        
    }
    
    #Identify which are identical across meta data frames. 
    identicalColumns <- unlist(lapply(commonColumns, function(YY){
        
            tmpDF <- NULL
            for(i in seq_along(SEObjectList)){
                tmpDF2 <- SummarizedExperiment::colData(SEObjectList[[i]])[,c('Sample', YY)]
                colnames(tmpDF2) <- c('Sample', paste('X',i,sep=''))
        
                if(!is.null(tmpDF)){
                
                    tmpDF <- dplyr::full_join(tmpDF, as.data.frame(tmpDF2), by = 'Sample')
                    
                }else{
                
                    tmpDF <- as.data.frame(tmpDF2)
                }
        
            }
                
            all(apply(tmpDF[,-1],1, function(XX) { 
                        tmp <- unique(XX) 
                        length(tmp[which(!is.na(tmp))]) ==1
            }))
        }))
    
    #Created merged metadata
    metadata = NULL
    for(i in seq_along(SEObjectList)){
        tmpDF2 <- SummarizedExperiment::colData(SEObjectList[[i]])[,commonColumns[identicalColumns]]
        
        if(!is.null(metadata)){
            
            if(any(!rownames(tmpDF2) %in% rownames(metadata))){
                
                metadata <- rbind(metadata, 
                              tmpDF2[!rownames(tmpDF2) %in% rownames(metadata),])
            }
            
        }else{

            metadata <- tmpDF2
        }
        
    }
                
    ##Create merged rowData, if it is different:
    rowLengths <- lengths(lapply(SEObjectList, 
                    function(XX) rownames(SummarizedExperiment::rowData(XX))))
    if(length(unique(rowLengths)) !=1 & is.null(SummarizedExperiment::rowRanges(SEObjectList[[1]]))){
        rowdata = NULL
        for(i in seq_along(SEObjectList)){
            tmpDF2 <- SummarizedExperiment::rowData(SEObjectList[[i]])

            if(!is.null(rowdata)){

                if(any(!rownames(tmpDF2) %in% rownames(metadata))){

                    rowdata <- rbind(rowdata, 
                                  tmpDF2[!rownames(tmpDF2) %in% rownames(rowdata),])
                }

            }else{

                rowdata <- tmpDF2
            }

        }
        
        newSE <- SummarizedExperiment::SummarizedExperiment(assayList, 
                                                        rowdata = rowdata[sort(allFeatures),],
                                                        colData = metadata[sort(allSamples),])
               
    }else if(length(unique(rowLengths)) !=1 & !is.null(SummarizedExperiment::rowRanges(SEObjectList[[1]]))){
        
        rowdata = NULL
        for(i in seq_along(SEObjectList)){
            tmpDF2 <- SummarizedExperiment::rowRanges(SEObjectList[[i]])

            if(!is.null(rowdata)){

                if(any(!rownames(tmpDF2) %in% rownames(metadata))){

                    rowdata <- c(rowdata, 
                                  tmpDF2[!rownames(tmpDF2) %in% rownames(rowdata)])
                }

            }else{

                rowdata <- tmpDF2
            }

        }
        newSE <- SummarizedExperiment::SummarizedExperiment(assayList, 
                                                        rowRanges = rowdata[sort(allFeatures)],
                                                        colData = metadata[sort(allSamples),])
        
    }else if(!is.null(SummarizedExperiment::rowRanges(SEObjectList[[1]]))){
        
        rowdata <-  SummarizedExperiment::rowRanges(SEObjectList[[1]])
        
        newSE <- SummarizedExperiment::SummarizedExperiment(assayList, 
                                                        rowRanges = rowdata[sort(allFeatures)],
                                                        colData = metadata[sort(allSamples),])
        
    }else if(!is.null(SummarizedExperiment::rowData(SEObjectList[[1]]))){
    
        rowdata <-  SummarizedExperiment::rowData(SEObjectList[[1]])
        
        newSE <- SummarizedExperiment::SummarizedExperiment(assayList, 
                                    rowData = rowdata[sort(allFeatures),],
                                    colData = metadata[sort(allSamples),])
        
    }else {
        newSE <- SummarizedExperiment::SummarizedExperiment(assayList,
                    colData = metadata[sort(allSamples),])
    }
                                        

    return(newSE)
}
                        
#' @title mergeUniqueRows
#' @description \code{mergeUniqueRows} Merges SummarizedExperiments with the same assays, 
#'       but only partially overlapping columns and different rows. 
#' @param SEObjectList A list of SummarizedExperiments to be merge.
#' @param fill Default is NA. Fill for missing values/samples between objects
#' @return One SE object with all assays and samples
#' @noRd
                                         
mergeUniqueRows <- function(SEObjectList, newSE, fill = 0){
    
    ##Identify all sample names
    allSamples <- colnames(newSE)
                                
    ##Identify all rownames
    allFeatures <- unique(unlist(lapply(SEObjectList,  function(XX) rownames(XX))))
    allFeatures <- allFeatures[order(allFeatures)]
                                        
    ##Identify assayList
    assayNames <- lapply(SEObjectList, function(XX){
            names(SummarizedExperiment::assays(XX))
        })
    if(length(unique(lengths(assayNames))) != 1 ){
    
        stop('Assay names do not align. This function is not meant to merge SEs with different assays')
        
    }
                                         
    ## merge each assay        
    assayList <- lapply(assayNames[[1]], function(XX){

        full_mat <- do.call('rbind', lapply(seq_along(SEObjectList), function(YY){
            tmpMat <- SummarizedExperiment::assays(SEObjectList[[YY]])[[XX]]
            
            #Fill in missing samples
            if(any(!allSamples %in% colnames(tmpMat))){
                
                filled_data <- do.call('cbind',     
                    lapply(which(!allSamples %in% colnames(tmpMat)), function(x){
                        rep(fill, dim(tmpMat)[1])
                    }))
                
                colnames(filled_data) <- allSamples[!allSamples %in% colnames(tmpMat)]
                
                new_mat <- cbind(tmpMat, filled_data)

            }else{

                new_mat <- tmpMat

            }
            new_mat <- new_mat[,order(colnames(new_mat))]
        }))
        
       full_mat
    })
        
    #Set names correctly
    names(assayList) <- assayNames[[1]]
                                                      
    rbinded_SE <- SummarizedExperiment::SummarizedExperiment(assayList,
                        colData = SummarizedExperiment::colData(newSE)[order(allSamples),])
    return(rbinded_SE)
}


#' @title Run a mathematical transform on a ChAI object.
#'
#' @description \code{transformChAI} For associations, abnormally distributed data can break models. transformChAI does several specific transformations to data in ChAI objects, 
#'                  so that they can be used in associative modeling functions. 
#' @param ChAIObject A SummarizedExperiment generated from ChAI (makeChromVAR, normalizePseudobulk, or importGeneralModality)
#' @param transformType A string that must be either 'log10p' for a log10+1 transform, 'logp' for log e + 1, 
#'         'CLR' for a center-log ratio transform, and 'meanShift' (data - rowMeans(data)). 
#'          Additional Cox-Box transforms inclde r, rv, r2, rv2, l, lv, l2, and lv2, based on this Nature paper. 
#'          https://www.nature.com/articles/s41598-019-41315-w & the corresponding package 'countTransformers'
#'
#'
#' @return A ChAI object with the data transformed
#'
#'
#'
#' @examples
#' \dontrun{
#'   tObject <- transformChAI(geneExpression, transformType = 'CLR')
#' }
#'
#' @export
#' @keywords data_object_manipulation
#'

transformChAI <- function(ChAIObject, transformType = 'clr', ...){

    #need to check for valid ChAI Object

    assayList <- SummarizedExperiment::assays(ChAIObject)

    addVariable = list(...)
    if(any(names(addVariable) == 'low')){
        low1 = addVariable$low
    }else{
    
        low1 = 0.001
    }
    
    if(any(names(addVariable) == 'upp')){
        upp1 = addVariable$upp
    }else{
    
        upp1 = 100
    }
    
    if(any(names(addVariable) == 'lib.size')){
        lib.size = addVariable$lib.size
    }else{
    
        lib.size = NULL
    }


    if(tolower(transformType) == 'log10p'){

        assayList2 <- lapply(assayList, function(x){
                    mat = x
                    mat[is.na(mat)] = 0
                    log10(mat + 1)
        }) 
        names(assayList2) <- names(assayList)

    } else if(tolower(transformType) == 'clr'){

        assayList2 <- lapply(assayList, function(x){
                    mat = x
                    mat[is.na(mat)] = 0
                    stats::clr(mat)
        }) 
        names(assayList2) <- names(assayList)

    } else if(tolower(transformType) == 'log1p'){

        assayList2 <- lapply(assayList, function(x){
                    mat = x
                    mat[is.na(mat)] = 0
                    log(mat + 1)
        }) 
        names(assayList2) <- names(assayList)

    } else if(tolower(transformType) == 'meanshift'){

        assayList2 <- lapply(assayList, function(x){
                    mat = x
                    mat[is.na(mat)] = 0
                    mat - rowMeans(mat)
        }) 
        names(assayList2) <- names(assayList)

    }else if(tolower(transformType) == 'l'){

        assayList2 <- list()
        deltaList = list()
        #https://github.com/cran/countTransformers/blob/master/R/lTransformer.R
        tmpFunction <- function(delta, vector1){
            aa=log2(vector1+(1/delta))
            res=(mean(aa, na.rm=TRUE)-stats::median(aa, na.rm=TRUE))^2
            return(res)
        }
        for(x in seq_along(assayList)){
            mat = assayList[[x]]
            mat[is.na(mat)] = 0
            ## From countTransformers on CRAN, which is no longer maintained. 
            res.delta=stats::optimize(tmpFunction, vector1=c(mat),lower=low1, upper=upp1)
            y=log2(c(mat)+(1/res.delta$minimum))
            mat2=matrix(y, ncol=ncol(mat))
            rownames(mat2)=rownames(mat)
            colnames(mat2)=colnames(mat)
            assayList2 = append(assayList2, mat2)
            deltaList = append(deltaList, res.delta$minimum)
            
        }
        names(assayList2) <- names(assayList)
        names(deltaList) <- names(assayList)
        ChAIObject@metadata = append(ChAIObject@metadata, list('DeltaOptimization'= deltaList))

    }else if(tolower(transformType) == 'l2'){

        assayList2 <- list()
        deltaList = list()
        #https://github.com/cran/countTransformers/blob/master/R/l2Transformer.R
        tmpFunction1 <- function(delta, vector1){
            aa=log2(vector1+(1/delta))
            res=(mean(aa, na.rm=TRUE)-stats::median(aa, na.rm=TRUE))^2
            return(res)
        }
        for(x in seq_along(assayList)){
            mat = assayList[[x]]
            mat[is.na(mat)] = 0
            ## From countTransformers on CRAN, which is no longer maintained. 
            res.delta=stats::optimize(tmpFunction1, vector1=c(mat),lower=low1, upper=upp1)
            mat2=log2(mat+(1/res.delta$minimum))
            rownames(mat2)=rownames(mat)
            colnames(mat2)=colnames(mat)
            assayList2 = append(assayList2, mat2)
            deltaList = append(deltaList, res.delta$minimum)
            
        }
        names(assayList2) <- names(assayList)
        names(deltaList) <- names(assayList)
        ChAIObject@metadata = append(ChAIObject@metadata, list('DeltaOptimization'= deltaList))
        
        

    }else if(tolower(transformType) == 'lv'){

        assayList2 <- list()
        deltaList = list()
        #https://github.com/cran/countTransformers/blob/master/R/lvTransformer.R
        tmpFunction2 <- function(delta, mat, lib.size=NULL){
            if(is.null(lib.size))
              {
                lib.size=colSums(mat)
              }

              tt <- t(mat + 0.5)/(lib.size + 1) * 1e+06
              mat2 <- t(log2(tt+1/delta))
              vec = c(mat2) 
              res=(mean(vec, na.rm=TRUE)-stats::median(vec, na.rm=TRUE))^2

              return(res)
         }
        
        for(x in seq_along(assayList)){
            mat = assayList[[x]]
            mat[is.na(mat)] = 0
            ## From countTransformers on CRAN, which is no longer maintained. 
            res.delta=stats::optimize(tmpFunction2, mat=mat,lower=low1, upper=upp1, lib.size=NULL)
            mat2=log2(mat+(1/res.delta$minimum))
            rownames(mat2)=rownames(mat)
            colnames(mat2)=colnames(mat)
            assayList2 = append(assayList2, mat2)
            deltaList = append(deltaList, res.delta$minimum)
            
        }
        names(assayList2) <- names(assayList)
        names(deltaList) <- names(assayList)
        ChAIObject@metadata = append(ChAIObject@metadata, list('DeltaOptimization'= deltaList))
        
        

    }else if(tolower(transformType) == 'lv2'){

        assayList2 <- list()
        deltaList = list()
        #https://github.com/cran/countTransformers/blob/master/R/lvTransformer.R
        tmpFunction3 <- function(delta, mat, lib.size=NULL){
             if(is.null(lib.size)){
                lib.size=colSums(mat)
              }

              tt <- t(mat + 0.5)/(lib.size + 1) * 1e+06
              mat2 <- t(log2(tt+1/delta))

              md=apply(mat2, 2, stats::median, na.rm=TRUE)
              me=apply(mat2, 2, mean, na.rm=TRUE)
              res=sum((md-me)^2, na.rm=TRUE)

              return(res)
         }
        
        for(x in seq_along(assayList)){
            mat = assayList[[x]]
            mat[is.na(mat)] = 0
            ## From countTransformers on CRAN, which is no longer maintained. 
            res.delta=stats::optimize(tmpFunction3, mat=mat,lower=low1, upper=upp1, lib.size=NULL)
            
            delta.optim = res.delta$minimum
              if(is.null(lib.size))
              {
                lib.size=colSums(mat)
              }

              tt <- t(mat + 0.5)/(lib.size + 1) * 1e+06
              mat2 <- t(log2(tt+1/delta.optim))
            
            assayList2 = append(assayList2, mat2)
            deltaList = append(deltaList, res.delta$minimum)
            
        }
        names(assayList2) <- names(assayList)
        names(deltaList) <- names(assayList)
        ChAIObject@metadata = append(ChAIObject@metadata, list('DeltaOptimization'= deltaList, 'TransformType' = transformType))
        
        

    }else if(tolower(transformType) == 'r'){

        assayList2 <- list()
        deltaList = list()
        #https://github.com/cran/countTransformers/blob/master/R/rTransformer.R
        tmpFunction4 <- function(eta,vec){
             aa=(vec^(1/eta)/(1/eta))
              res=(mean(aa, na.rm=TRUE)-stats::median(aa, na.rm=TRUE))^2
              return(res)
         }
        
        for(x in seq_along(assayList)){
            mat = assayList[[x]]
            mat[is.na(mat)] = 0
            ## From countTransformers on CRAN, which is no longer maintained. 
            res.eta=stats::optimize(tmpFunction4, vec=c(mat),lower=low1, upper=upp1)
            
            y=c(mat)^(1/res.eta$minimum)/(1/res.eta$minimum)

            # convert back to matrix
            mat2=matrix(y, ncol=ncol(mat))
            rownames(mat2)=rownames(mat)
            colnames(mat2)=colnames(mat)
            
            assayList2 = append(assayList2, mat2)
            deltaList = append(deltaList, res.eta$minimum)
            
        }
        names(assayList2) <- names(assayList)
        names(deltaList) <- names(assayList)
        ChAIObject@metadata = append(ChAIObject@metadata, list('DeltaOptimization'= deltaList, 'TransformType' = transformType))
        
        

    }else if(tolower(transformType) == 'r2'){

        assayList2 <- list()
        deltaList = list()
        #https://github.com/cran/countTransformers/blob/master/R/r2Transformer.R
        tmpFunction5 <- function(eta,mat){
             aa=(mat^(1/eta)/(1/eta))
            #calculate sum of subject-specific squared difference between sample mean & median
             md=apply(mat, 2, stats::median, na.rm=TRUE)
              me=apply(mat, 2, mean, na.rm=TRUE)
              res=sum((md-me)^2, na.rm=TRUE)

             return(res)
         }
        
        for(x in seq_along(assayList)){
            mat = assayList[[x]]
            mat[is.na(mat)] = 0
            ## From countTransformers on CRAN, which is no longer maintained. 
            res.eta=stats::optimize(tmpFunction5, mat=mat,lower=low1, upper=upp1)
            
            y=c(mat)^(1/res.eta$minimum)/(1/res.eta$minimum)

           mat2=mat^(1/res.eta$minimum)/(1/res.eta$minimum)
           rownames(mat2)=rownames(mat)
           colnames(mat2) = colnames(mat)
            
            assayList2 = append(assayList2, mat2)
            deltaList = append(deltaList,res.eta$minimum)
            
        }
        names(assayList2) <- names(assayList)
        names(deltaList) <- names(assayList)
        ChAIObject@metadata = append(ChAIObject@metadata, list('DeltaOptimization'= deltaList, 'TransformType' = transformType))
        
        

    }else if(tolower(transformType) == 'rv'){

        assayList2 <- list()
        deltaList = list()
        #https://github.com/cran/countTransformers/blob/master/R/rvTransformer.R
        tmpFunction6 <- function(eta, mat,lib.size=NULL){
             if(is.null(lib.size)){
                lib.size=colSums(mat)
              }

            tt <- t(mat + 0.5)/(lib.size + 1) * 1e+06
            mat2 <- t(tt^(1/eta)/(1/eta))
            vec = c(mat2) 
            res=(mean(vec, na.rm=TRUE)- stats::median(vec, na.rm=TRUE))^2

            return(res)
         }
        
        for(x in seq_along(assayList)){
            mat = assayList[[x]]
            mat[is.na(mat)] = 0
            ## From countTransformers on CRAN, which is no longer maintained. 
            res.eta=stats::optimize(tmpFunction6, mat=mat, lib.size=lib.size, lower=low1, upper=upp1)
            
           eta.optim=res.eta$minimum
              if(is.null(lib.size))
              {
                lib.size=colSums(mat)
              }

              tt <- t(mat + 0.5)/(lib.size + 1) * 1e+06
              mat2 <- t(tt^(1/eta.optim)/(1/eta.optim))
              rownames(mat2)=rownames(mat)
              colnames(mat2)=colnames(mat)
            
            assayList2 = append(assayList2, mat2)
            deltaList = append(deltaList, eta.optim)
            
        }
        names(assayList2) <- names(assayList)
        names(deltaList) <- names(assayList)
        ChAIObject@metadata = append(ChAIObject@metadata, list('EtaOptimization'= deltaList, 'TransformType' = transformType))
        
        

    }else if(tolower(transformType) == 'rv2'){

        assayList2 <- list()
        deltaList = list()
        #https://github.com/cran/countTransformers/blob/master/R/rvTransformer.R
        tmpFunction7 <- function(eta, mat,lib.size=NULL){
             if(is.null(lib.size))
              {
                lib.size=colSums(mat)
              }
              tt <- t(mat + 0.5)/(lib.size + 1) * 1e+06
              mat2 <- t(tt^(1/eta)/(1/eta))
              md=apply(mat2, 2, stats::median, na.rm=TRUE)
              me=apply(mat2, 2, mean, na.rm=TRUE)
              res=sum((md-me)^2, na.rm=TRUE)

            return(res)
         }
        
        for(x in seq_along(assayList)){
            mat = assayList[[x]]
            mat[is.na(mat)] = 0
            ## From countTransformers on CRAN, which is no longer maintained. 
            res.eta=stats::optimize(tmpFunction7, mat=mat, lib.size=lib.size, lower=low1, upper=upp1)
            
           eta.optim=res.eta$minimum
              if(is.null(lib.size))
              {
                lib.size=colSums(mat)
              }
              tt <- t(mat + 0.5)/(lib.size + 1) * 1e+06
              mat2 <- t(tt^(1/eta.optim)/(1/eta.optim))
              rownames(mat2)=rownames(mat)
              colnames(mat2)=colnames(mat)
            
            assayList2 = append(assayList2, list(mat2))
            deltaList = append(deltaList, eta.optim)
            
        }

        names(assayList2) <- names(assayList)
        names(deltaList) <- names(assayList)
        ChAIObject@metadata = append(ChAIObject@metadata, list('EtaOptimization'= deltaList, 'TransformType' = transformType))
        
        

    }else{
        stop('transformType was not reconciled. Options include log10, meanshift, and clr.')
    }
        
    SummarizedExperiment::assays(ChAIObject, withDimnames=FALSE) = assayList2
    ChAIObject@metadata$Type = 'General'
    ChAIObject@metadata$History = append(ChAIObject@metadata$History, 
                                         paste("transformChAI", utils::packageVersion("ChAI")))
    
    return(ChAIObject)

}

#' @title Functions for identifying genes that pass threshold for a given cell types. 
#'
#' @description \code{thresholdGenes} Identifies which genes pass the threshold settings for a given cell type
#' @param rnaSE A scRNA SummarizedExperiment from makePseudobulkRNA. 
#' @param factors Categorical factors, found within the sample metadata. If numeric factors are provided,
#'                   they will be avoided. If genes pass the provided threshold in any group, 
#'                   they will be returned.
#' @param detectionThreshold A number between 0 and 1, representing the mean detection rate threshold for a given gene to be modeled. 
#'   This detection rate is calculated for each sample and cell type during makePseudobulkRNA, and represents the percentage of cells that have a transcript for a given gene. Over all samples, the average has to be above this to be modeled. Default is 0.01. 
#' @param expressionThreshold A number greater than zero, representing the expression threshold for modeling. A given gene, on average across all samples, expressed above this threshold. The default is 0. 
#' @param cellCountThreshold The minimum number of cells in a given pseudobulk for the pseudobulk to be included in analysis. If fewer than this number of cells are found, then the sample will be dicarded The number of cells within the pseudobulked scRNA. Default is 10 cells. 
#' @param verbose Set TRUE to display additional messages. Default is FALSE.
#'
#' @return output_vector A linear model
#'
#' @noRd

thresholdGenes <- function(rnaSE,   
                           factors = NULL,
                        cellPopulation = 'ALL',
                    detectionThreshold = 0.01,
                    expressionThreshold = 0,
                    cellCountThreshold = 10){
    
  if(isChAIObject(rnaSE, type = 'data', returnType = TRUE) != 'scRNA'){

    stop('rnaSE is not a ChAI scRNA Object (normalized, pseudobulked via ChAI.)')

  }
    
  detectionRates = rnaSE@metadata$detectionRates
  summarizedData = rnaSE@metadata$summarizedData
    
  if(!all(cellPopulation %in% names(SummarizedExperiment::assays(rnaSE))) &
     all(tolower(cellPopulation) != 'all')){
      
    stop('rnaSE does not contain an assay that matches the cellPopulation input variable.')
      
  }else if(all(tolower(cellPopulation) == 'all')){
    
          cellPopulation = SummarizedExperiment::assayNames(rnaSE)
      
  }
      
  if(!methods::is(cellCountThreshold, 'numeric')){
 
      stop('cellCountThreshold must be numeric.')
      
 }

  metadf = SummarizedExperiment::colData(rnaSE)
      
  if(!is.null(factors) & any(factors %in% colnames(metadf))){

      charClass = factors[unlist(lapply(factors, function(XX) { 
          class(metadf[,XX]) %in% c('character','factor')}))]
      
 }else{
    
      charClass = character(0)
      
    }
    
  geneList = lapply(cellPopulation, function(cellPop){
          passThreshold = SummarizedExperiment::assays(summarizedData)[['CellCounts']][cellPop,] > cellCountThreshold 
          subDetect = detectionRates[passThreshold,]
          subRNA = rnaSE[passThreshold,]
      
          if(length(charClass) == 0){
      
              detectMean <- rowMeans(SummarizedExperiment::assays(subDetect)[[cellPop]])
              expressMean <- rowMeans(SummarizedExperiment::assays(subRNA)[[cellPop]])
              
              intersect(names(which(expressMean > expressionThreshold)),
                                              names(which(detectMean > detectionThreshold)))
              
            }else{

                 #Identify groups for a given categorical variable. 
              unique(unlist(lapply(charClass, function(XX){
                    groups = unique(metadf[passThreshold,XX])
                    groups = groups[!is.na(groups)]
                    unique(unlist(lapply(groups, function(ZZ){
                                   #Test to see which genes pass threshold within that group
                                    specificSamples = metadf[,XX] == ZZ
                                    specificSamples[is.na(specificSamples)] = FALSE
                                    detectMean <- rowMeans(SummarizedExperiment::assays(
                                        subDetect[,specificSamples])[[cellPop]])
                        
                                    expressMean <- rowMeans(SummarizedExperiment::assays(
                                        subRNA[,specificSamples])[[cellPop]])
                        
                                    intersect(names(which(expressMean > expressionThreshold)),
                                              names(which(detectMean > detectionThreshold)))
                              })))
                })))
            }
            
      })
     names(geneList) = cellPopulation
    return(geneList)
}
                                         
                                         


#' @title Rename cell types (or assays) within a ChAI Object
#'
#' @description \code{renameCellTypes} Allows you to modify the cell type names for a MOCHA SampleTileObject, ChAI pseudobulk scRNA object, or just any general assay from
#'                    the assay names, GRanges column names, and summarizedData (within the metadata), all at once. 
#'
#' @param Object A SummarizedExperiment object from MOCHA or ChAI
#' @param oldNames A list of cell type names that you want to change. 
#' @param newNames A list of new cell type names to replace the old names with. 
#' @return A MOCHA SampleTile object with new cell types. 
#' @examples
#' \dontrun{
#'   chromSE <- renameCellTypes(chromSE, 'CD16_Mono', 'CD16 Mono')
#' }
#'
#' @keywords data_object_manipulation
#'
#'
#' @export
renameCellTypes <- function(Object,
                              oldNames,
                              newNames) {

  if (methods::is(Object, "SummarizedExperiment")){

    if(!any(names(Object@metadata) %in% 'History')){
         stop("Object was not generated by ChAI or MOCHA.")
    } 


    if(!any(grepl('getSampleTileMatrix|makePseudobulkRNA|importGeneralModality|reformatChromVARList', unlist(Object@metadata$History)))){
      stop("Object is not an SampleTile object from MOCHA, or a SummarizedExperiment object from ChAI's makePseudobulkRNA or importGeneralModality.")
    }

    if(!all(oldNames %in% names(SummarizedExperiment::assays(Object)))){
      stop('Not all of the provided oldNames exist in the current Object')
    }

    if(length(oldNames) != length(newNames)){
      stop('oldNames and newNames are different lengths.')
    }

    #assay names edits
    assayNames <- names(SummarizedExperiment::assays(Object))
    assayNames[match(oldNames, assayNames)] = newNames
    names(SummarizedExperiment::assays(Object)) = assayNames

    if(any(grepl('getSampleTileMatrix', unlist(Object@metadata$History)))){

        #rowRanges edits
        mColData <- GenomicRanges::mcols(SummarizedExperiment::rowRanges(Object))
        colnames(mColData)[match(oldNames, colnames(mColData))] = newNames
        GenomicRanges::mcols(SummarizedExperiment::rowRanges(Object)) = mColData

    }

    if(any(grepl('getSampleTileMatrix|makePseudobulkRNA|reformatChromVARList', unlist(Object@metadata$History)))){
        
        #summarized cell type metadata edits
        oldSumData <- rownames(Object@metadata$summarizedData)
        oldSumData[match(oldNames,oldSumData)] = newNames
        rownames(Object@metadata$summarizedData) = oldSumData

    }
      
     if(any(grepl('makePseudobulkRNA', unlist(Object@metadata$History)))){
        
        #summarized cell type metadata edits
        oldSumData <- names(SummarizedExperiment::assays(Object@metadata$detectionRates))
        oldSumData[match(oldNames,oldSumData)] = newNames
        names(SummarizedExperiment::assays(Object@metadata$detectionRates)) = assayNames

    }
  
    return(Object)

  }else{
    stop("Object is not an SampleTile object from MOCHA.")
  }                         

}

#' @title Get Population-level Metadata
#'
#' @description \code{getPopulationMetaData} Extract population-level metadata (like cell counts) from a ChAI (or MOCHA) object.
#' @param ChAIObj A ChAI SummarizedExperiment, whether it's a ChAI data object or a ChAI model object
#' @param Measurement A string describing which population-level metadata you want. The default is NULL, which will return a list of all possible types of population metadata. 
#' @return A data frame with population-level information across samples and cell types
#'
#'
#' @keywords data_object_manipulation
#'
#'
#' @examples
#' \dontrun{
#'   getAdditionalData(modelObj, )
#' }
#'
#' @export
#'
getPopulationMetaData <- function(ChAIObj, Measurement){

    obj <- isChAIObject(ChAIObj, type = 'data', returnType = TRUE)

    if(obj %in% c('scATAC', 'ChromVAR', 'scRNA')){

        popData <- obj@metadata$summarizedData
        allTypes <- names(SummarizedExperiment::assays(popData))

        if(is.null(Measurement)){

            return(allTypes)

        }else if(Measurement %in% allTypes){

            mat1 <- SummarizedExperiment::assays(obj@metadata$summarizedData)[[Measurement]]

        }else{

            stop('Measurement was not found within the ChAI Object. Run getPopulationMetaData(ChAIObj, Measurement = NULL) to see all options.')
        
        }

       
    }else{

        stop(stringr::str_interp('Population-level metadata is only stored in ChAI Objects with ChromVAR and scRNA data, or a MOCHA object. The provided ChAI object contains ${obj} data.'))
    }

    
    
    return(mat1)
    
}
       

#' @title Extract additional metadata from a ChAI data or model Object
#'
#' @description \code{getAdditionalData} Returns a wide range of metadata from ChAI objects, including
#'                  population-level metadata (scRNA, and scATAC), gene detection rates within a sample-celltype (scRNA),
#'                   residuals (models), and random effect variance (models)
#' @param ChAIObj A ChAI SummarizedExperiment, whether it's a ChAI data object or a ChAI model object
#' @param feature The type of data you want. If null, it will return the list of all options for that objct. 
#'    Options include 'summarizedData', which contains population-specific metadata like cell counts, 
#'    'detectionRates', which contains the percentage of a population with transcript of a given gene (scRNA only)
#'     'Residuals', which contains a SummarizedExperiment of Residuals after modeling
#'     or 'Variance'/'RandomEffectVariance' which will return a data.frame of variance from a model. 
#' @return A list of additional data available within a given ChAI object, or a specific data object from that ChAI object.  
#'
#'
#' @keywords data_object_manipulation
#'
#'
#' @examples
#' \dontrun{
#'   getAdditionalData(modelObj, )
#' }
#'
#' @export
#'

getAdditionalData <- function(ChAIObj, feature = NULL){

    objType <- isChAIObject(ChAIObj, type ='data', returnType = TRUE)
    if(objType == 'model'){

        objType <- isChAIObject(ChAIObj, type ='model', returnType = TRUE)

    }
    
    featureSet = names(ChAIObj@metadata)
 
    if(all(is.null(feature))){
        
        return(featureSet)
        
    }

    if(length(feature) > 1 | !methods::is(feature, 'character')){
    
        stop('feature is not a string or is a list-like object. feature must either be NULL, or a single string.')
        
    }
    
    allTypes <- getModelTypes()

    if(objType %in% allTypes & feature %in% featureSet){

        return(ChAIObj@metadata[[feature]])

    }else if(objType %in% c('scATAC', 'scRNA', 'ChromVAR', 'scRNA') & feature %in% featureSet){

        return(ChAIObj@metadata[[feature]])

    }else{

       stop(stringr::str_interp('ChAIObject and/or feature not recognized. Set feature to NULL to see all additional data within the ChAI data or model object.'))

    }  

}


#' @title Get the gene detection rates from pseudobulked scRNA
#'
#' @description \code{getDetectionRates} Get sample-wise gene detection rates (i.e. percent of cells with transcript across samples) for a given cell type from a ChAI scRNA object.
#' @param ChAIObj A ChAI SummarizedExperiment, whether it's a ChAI data object or a ChAI model object
#' @param CellType A string describing which population-level metadata you want. The default is NULL, which will return a list of all possible types of population metadata. 
#' @return A data frame with the detection rate for all genes across all samples
#'
#'
#' @keywords data_object_manipulation
#'
#'
#' @examples
#' \dontrun{
#'   getDetectionRates(dataObj, 'CD4 Naive')
#' }
#'
#' @export
#'
getDetectionRates <- function(ChAIObj, CellType = NULL){

    obj <- isChAIObject(ChAIObj, type = 'data', returnType = TRUE)

    if(obj == 'scRNA'){

        detectRate <- obj@metadata$detectionRates
        allTypes <- names(SummarizedExperiment::assays(detectRate))

        if(all(!is.null(CellType))){

            return(detectRate)
            
        }else if(methods::is(CellType, 'character') & length(CellType) == 1){

            stop('CellType is either not a string, or is a vector of multiple strings. It must be a single string.')

        }else if(all(CellType %in% allTypes)){

            mat1 <- SummarizedExperiment::assays(detectRate)[[CellType]]

        }else{

            stop('CellType was not found within the ChAI Object. Run names(SummarizedExperiment::assays(ChAIObj)) to see all cell type names.')
        
        }

       
    }else{

        stop(stringr::str_interp('ChAI Objects must contain scRNA data. The provided ChAI Object contains ${obj} data.'))
    }

    
    
    return(mat1)
    
}
       



#' @title \code{isChAIObject}
#'
#' @description \code{isChAIObject} Checks if the object is a SummarizedExperiment generated by ChAI or MOCHA
#'
#' @param Object A SummarizedExperiment object from MOCHA or ChAI
#' @param type Can be 'data' or 'model'
#' @param returnType Boolean. Determines whether to return the type of object.
#' @return A boolean or String
#' @noRd
isChAIObject <- function(Object, type = 'data', returnType = FALSE) {
   
  if (methods::is(Object, "SummarizedExperiment")){

    if(!any(names(Object@metadata) %in% 'History') & type == 'data'){
         stop("Object was not generated by ChAI or MOCHA.")
    } else if(!any(grepl('getSampleTileMatrix|makePseudobulkRNA|importGeneralModality|reformatChromVARList', unlist(Object@metadata$History))) & type == 'data'){
      stop("Object is not an SampleTile object from MOCHA, or a SummarizedExperiment object from ChAI's makePseudobulkRNA or importGeneralModality.")
    }else if(!any(grepl('getSampleTileMatrix|makePseudobulkRNA|importGeneralModality|reformatChromVARList', unlist(Object@metadata$History))) & type == 'data'){
      stop("Object is not an SampleTile object from MOCHA, or a SummarizedExperiment object from ChAI's makePseudobulkRNA, makeChromVAR, or importGeneralModality.")
    }else if(! type  %in% c('data', 'model')){
      stop("type not recognized. Must be either 'data' or 'model'")
    }else if(type == 'data' & returnType){

      specObject <- unlist(lapply(c("transformChAI", 'getSampleTileMatrix',
                    'makePseudobulkRNA','importGeneralModality', 'reformatChromVARList', 
                    'runSSGSEA'), function(XX){
        
          any(grepl(XX, Object@metadata$History)) 
        }))

      if(specObject[6]){
        return('General')
      }else if(specObject[1]){
        return('Transformed')
      }else if(specObject[2]){
        return('scATAC')
      }else if(specObject[3]){
        return('scRNA')
      }else if(specObject[4]){
        return('General')
      }else if(specObject[5]){
        return('ChromVAR')
      }else{
        return('model')
      }
            
    }else if(type == 'data'){

          specObject <- unlist(lapply(c("transformChAI", 'getSampleTileMatrix',
                    'makePseudobulkRNA','importGeneralModality', 'reformatChromVARList'), function(XX){
        
          any(grepl(XX, Object@metadata$History)) 
        }))

        if(any(specObject)){

            return(TRUE)
            
        }

    }

    if(!any(names(Object@metadata) %in% 'Type') & type == 'model'){
         stop("Object is not a model object generated by ChAI.")
    } else if(!any(grepl(paste(getModelTypes(), collapse = '|'), Object@metadata$Type)) & type == 'model'){
         stop("Object is not a ChAI model object.")
    }else if(type == 'model' & returnType){
      return(Object@metadata$Type)
    }
    return(FALSE)

  }else if(methods::is(Object, "list")){
        
       allModels = lapply(Object, function(XX) isChAIObject(XX, type = type, returnType = returnType))
       allModels = unique(unlist(allModels))
       allModels = allModels[allModels != 'FALSE']
       if(length(allModels) > 1){ return(FALSE)}
       return(allModels)
          
    }else{
      return(FALSE)
  }
}
