
#' @title Get model predictions, original measurements, and metadata for a given feature
#'
#' @description \code{modelPredictions} Uses the raw data object and the model prediction from a ChAI modeling function to generate a data.frame of raw and predicted features values for plotting.
#' @param dataObject The SummarizedExperiment object with real data. 
#' @param assay1 Name of the assay to analyze
#' @param measurement The specific measurement (gene, motif, tile, protein, etc...) that you want to look at within dataObject
#' @param specVariable The variable(s) of interest. If other fixed effects are present, they will be adjusted for. Must be actual model factors. Use getModelFactors to see the names of model factors in a given model object.
#' @param modelObject a SummarizedOutput object from modelPredict  
#' @param adjust A boolean, default to TRUE. Determines whether to generate an column with an adjusted measurement. The measurement will be adjusted for all factors that are not the specVariable within the model.
#' @param ignoreVariable Default is NULL. use this to specific whether there are any variables that you do not want to adjust for. 
#' @param outputDF A boolean, determines whether or not to output a data.frame with an additional column for each measurement, or a SummarizedExperiment. Only comes into play if multiple measurements are given. 
#' @return A summarized experiment where each assay is the data.frame of metadata, original measurement, predicted measurement, and adjusted measurement (option) for each measurement provided. 
#'
#'
#' @export
#' @keywords model_results
#'

modelPredictions <- function(dataObject, assay1, measurement, specVariable, modelObject, adjust = TRUE, ignoreVariable = NULL, outputDF = TRUE){
    
    ## Make sure the dataObject is a ChAIObject and then combine so that sample metadata can be pulled out. 
    
    data_type = isChAIObject(dataObject, type = 'data', returnType = TRUE)
    model_type = isChAIObject(modelObject, type = 'model', returnType = TRUE)
    logLink <- model_type == 'scRNA_Model'

    if(methods::is(modelObject, 'list') & all(assay1 %in% names(modelObject))){

        if(length(assay1) > 1){ stop('assay1 cannot be list. Please provide a single strong')}
        modelObject = modelObject[[assay1]]

    }
    
     ##Check data type to make sure dataObject and modelObject match
   if(model_type == 'scRNA_Model' & data_type != 'scRNA'){
        stop('A scRNA model was provided, but the dataObject is not ChAI scRNA object with normalized pseudobulk RNA. Please change the modelObject or the dataObject so that they match.')
                
    }else if(model_type == 'scATAC_Model' & data_type != 'scATAC'){
        stop('A scATAC model was provided but dataObject is not MOCHA SampleTile Object containing pseudobulking scATAC data. Please change the modelObject or the dataObject so that they match.')
                
    }else if(model_type == 'ChromVAR_Model' & data_type != 'ChromVAR'){
        stop('A ChromVAR model was provided, but the dataObject is not a ChAI ChromVAR object, generated by makeChromVAR. Please change the modelObject or the dataObject so that they match.')
                
    }else if(model_type == 'General_Model' & data_type != 'General' ){

        stop('A General model was provided, but the dataObject is not a ChAI General object, from importGeneralModality. Please change the modelObject or the dataObject so that they match.')
        
    }   
        
    ## Need to implement tracking of distributions for model_General
    if(model_type == 'General_Models'){
        warning('modelEstimates does notcurrently support non-Gaussian error distributions when used with model_General.')
    }

    #Test whether the measurement is found within their assays
    if(!all(measurement %in% rownames(dataObject))){
     stop(stringr::str_interp('measurement ${measurement} not found within dataObject. Please read documentation.'))
    }

    ## specificVariable
    if(length(specVariable) > 1){
        stop('specVariable must a single string')
    }      
    ## specifi
    if(!all(specVariable %in% colnames(SummarizedExperiment::colData(dataObject)))){
        stop(stringr::str_interp('One or all of the specVariable(s) ${specVariable} not found within the dataObject. Please read documentation.'))
    }else if(!all(specVariable %in% SummarizedExperiment::assayNames(modelObject))){
        ## specVariable appears to be a categorical variable. Figure out if it is, and then adapt to which options we want to visualize.
        ## look at all combinations of the specificVariable. 
        specList = paste(specVariable,unique(SummarizedExperiment::colData(dataObject)[,specVariable]), sep ='')
        specList = intersect(specList, SummarizedExperiment::assayNames(modelObject))
        if(length(specList) > 0){
            specVariable = specList
        }else{
            stop(stringr::str_interp('specVariable ${specVariable} was found as as a potentially categorical column in the metadata of the dataObject, but we could not align any categorical variables within it with the variables in the modelObject. Please ensure the specVariable is correct.'))
        }
    }
        
    ## Extract data and transform it. 
    if(data_type %in% c('scRNA', 'ChromVAR')){
        
        mat1 <- SummarizedExperiment::assays(dataObject[measurement,])[[assay1]] 
        mat1[is.na(mat1)] = 0
        dataObject2 = flattenChAI(dataObject, cellPopulations = assay1, metadataT= TRUE)
        metaData <-  SummarizedExperiment::colData(dataObject2)
        
    } else if(data_type %in% c('scATAC')){

        mat1 <- SummarizedExperiment::assays(dataObject[measurement,])[[assay1]] 
        
        mat1[is.na(mat1)] = 0
        mat1 <- log2(mat1 + 1)
        
        subSTM <- MOCHA::subsetMOCHAObject(dataObject, subsetBy = 'celltype', groupList = assay1)
        dataObject2 = MOCHA::combineSampleTileMatrix(subSTM)
        metaData <-  SummarizedExperiment::colData(dataObject2)
        
    }else {
        
        metaData <-  SummarizedExperiment::colData(dataObject)
        mat1 <- SummarizedExperiment::assays(dataObject[measurement,])[[assay1]] 
        
        mat1[is.na(mat1)] = 0
    }

    #Get a list of metadata information for each sample, and the factors that were used in the model. 
    assayList <- SummarizedExperiment::assays(modelObject)

    allVariables <- names(assayList)[!grepl('ZI_|Intercept',names(assayList))]
    numericVariables <- names(assayList)[names(assayList) %in% colnames(metaData)]
    remainingVariables <- allVariables[!allVariables %in% numericVariables]
    if(any(grepl(":", remainingVariables))){
        
        warning(stringr::str_interp('Interaction term ${grep(":", remainingVariables, value = TRUE)} will be ignored.'))
        remainingVariables <- grep(":", remainingVariables, value = TRUE, invert = TRUE)
        allVariables <- grep(":", allVariables, value = TRUE, invert = TRUE)
    }

    ## Log transform the FragmentNumbers so as to stabilize the model. But only if FragNumber is in the model. Same for CellCounts.
    if(any(colnames(metaData ) %in% c('FragNumber'))){
        metaData$rawFragNumber = metaData$FragNumber
        metaData$FragNumber <- log10(metaData $FragNumber)
    }
    if(any(colnames(metaData ) %in% c('CellCounts'))){
        metaData$rawCellCounts = metaData$CellCounts
        metaData$CellCounts <- log10(metaData $CellCounts)
    }

    #Create a metadata column for each categorical variable, one-hot encoding them. 
    if(length(remainingVariables) > 1){

        nextVariables <- lapply(remainingVariables, function(x) matchCategorical(metaData, x))
        newMetaData = do.call('cbind', nextVariables)
        colnames(newMetaData) <- remainingVariables
        metaData = cbind(metaData, newMetaData)
                                
    }else if(length(remainingVariables) > 0){
        
        newMetaData <- data.frame(newVar = matchCategorical(metaData, remainingVariables))
        colnames(newMetaData) <- remainingVariables
        metaData = cbind(metaData, newMetaData)
        
    }else{
        

    }

    subMeta <- metaData[, colnames(metaData) %in% allVariables, drop = FALSE]
    if(any(is.na(subMeta))){

        stop('Metadata in dataObject is NA. dataObject is likely not the object used for modeling. Please provide the object used for modeling.')

    }
                                
    allEstimates <- pbapply::pblapply(cl = NULL, seq_along(measurement), function(x){
        
        modelVals <- getModelValues(modelObject, measurement[[x]])[,'Estimate', drop=FALSE]

        newData <- data.frame('exp1' =  unlist(mat1[measurement[[x]],]))

        rownames(newData) = colnames(mat1)
        adjustVariables <- allVariables[! allVariables %in% c(specVariable, ignoreVariable)]
        if(adjust & length(adjustVariables) > 0){
            newData$orig_exp1 = newData$exp1
            
            # Use a dot product to find the model X metadata output. 
            allAdjusts = as.matrix(subMeta[,adjustVariables] ) %*% as.matrix(modelVals[adjustVariables,,drop=FALSE])
            predictVariables <- as.matrix(subMeta[, specVariable, drop = FALSE]) %*% 
                                        as.matrix(modelVals[specVariable, , drop = FALSE])
            # If modeled with a log-link related distribution, then transform after leveraging linearity.
            if(logLink){
                
                logExp1 <- log(newData$exp1) - rowSums(allAdjusts)
                newData$exp1 = exp(logExp1)
                
            }else{
                newData$exp1 = newData$exp1 - rowSums(allAdjusts)
            }
                
            if(any(grepl('Intercept', rownames(modelVals))) & !logLink){
                newData$Prediction = modelVals[grepl('Intercept', rownames(modelVals)),] + 
                                        unlist(as.list(predictVariables))
            }else if(any(grepl('Intercept', rownames(modelVals)))){
                
                newData$Prediction = exp(modelVals[grepl('Intercept', rownames(modelVals)),] + 
                                        unlist(as.list(predictVariables)))
                
            } else{
                newData$Prediction = exp(unlist(as.list(predictVariables)))
            }
            
            if(isChAIObject(dataObject, type = 'data', returnType = TRUE) == 'scATAC'){
                newData$exp1[newData$orig_exp1 ==0] = NA
                newData$Prediction[newData$orig_exp1 ==0] = NA
            }  
        
        }else{

            #If there are variables in the model:
            if(length(adjustVariables) > 0){
                allAdjusts = do.call('cbind',lapply(allVariables[!allVariables %in% c(specVariable)], function(x){
    
                                as.data.frame( modelVals[x,]*as.numeric(subMeta[,x]))
    
                                }))
                allAdjusts = sum(colMeans(allAdjusts))
    
            }else{
                allAdjusts = 0
            }
            
            predictVariables <- as.matrix(subMeta[, specVariable, drop = FALSE]) %*% as.matrix(modelVals[specVariable, , drop = FALSE])

            if(any(grepl('Intercept', rownames(modelVals)))){
                newData$Prediction = modelVals[grepl('Intercept', rownames(modelVals)),]  + unlist(as.list(predictVariables)) + allAdjusts
            }else{
                newData$Prediction = unlist(as.list(predictVariables)) + allAdjusts
            }
        
                
            if(logLink){
            
                newData$Prediction = exp(newData$Prediction)
                
            }
            
            if(isChAIObject(dataObject, type = 'data', returnType = TRUE) == 'scATAC'){
                newData$Prediction[newData$exp1 ==0] = NA
            } 
            
        }

        newData <- cbind(newData, metaData)
        newData
        
    })
        
    names(allEstimates) = measurement
                                
    if(length(measurement) == 1){
        allEstimates =allEstimates[[1]]
        allEstimates$Measurement = measurement
        allEstimates$Assay = assay1
        return(allEstimates)
        
    }else if(outputDF){

        allEstimates = do.call('rbind', lapply(seq_along(allEstimates), function(XX){
                            allEstimates[[XX]]$Measurement = measurement[[XX]]
                            allEstimates[[XX]]$Assay = assay1
                            allEstimates[[XX]]
                        }))
        return(allEstimates)

    }
    exp = SummarizedExperiment::SummarizedExperiment(allEstimates, metadata = SummarizedExperiment::rowData(dataObject[measurement,]))
   
    return(exp)
}
                                
                                
#' @title transformValues
#'
#' @description \code{.transformModelPrediction} Pull out a data.frame of all model values for a particular row (gene, tile, etc..).
#' @param modelSE A SummarizedExperiment object generated from any modeling function (model_general, model_scRNA, model_scATAC)
#' @param rowName A string, describing the row you want to analyze (tile from scATAC, gene for scRNA, or other from a model_general)
#'
#' @return A data.frame coefficient info by factor. 
#'
#'
#' @noRd
#'
                                
.transformModelPrediction <- function(newData, subMeta, allVariables, specVariable, ignoreVariable, adjust = TRUE){

     if(adjust){
            newData$orig_exp1 = newData$exp1
            adjustVariables <- allVariables[! allVariables %in% c(specVariable, ignoreVariable)]
            # Use a dot product to find the model X metadata output. 
            allAdjusts = as.matrix(modelVals[adjustVariables,,drop=FALSE]) %*% as.matrix(subMeta[,adjustVariables] )
            newData$exp1 = newData$exp1 - rowSums(allAdjusts)
            predictVariables <- as.matrix(subMeta[, specVariable, drop = FALSE]) %*% as.matrix(modelVals[specVariable, , drop = FALSE])
            if(any(grepl('Intercept', rownames(modelVals)))){
                newData$Prediction = modelVals[grepl('Intercept', rownames(modelVals)),] + unlist(as.list(predictVariables))
            }else{
                newData$Prediction = unlist(as.list(predictVariables))
            }

           
        
        }else{
    
            allAdjusts = do.call('cbind',lapply(allVariables[! allVariables %in% c(specVariable, ignoreVariable)], function(x){

                            as.data.frame( modelVals[x,]*as.numeric(subMeta[,x]))

                            }))
            predictVariables <- as.matrix(subMeta[, specVariable, drop = FALSE]) %*% as.matrix(modelVals[specVariable, , drop = FALSE])

            if(any(grepl('Intercept', rownames(modelVals)))){
                newData$Prediction = modelVals[grepl('Intercept', rownames(modelVals)),]  + unlist(as.list(predictVariables)) + sum(colMeans(allAdjusts))
            }else{
                newData$Prediction = unlist(as.list(predictVariables)) + sum(colMeans(allAdjusts))
            }
            
        }
    
}
                                
modelVals <- NULL 

#' @title Get coefficient estimates for all factors, given one feature name
#'
#' @description \code{getModelValues} Pull out a data.frame of all model values for a particular row (gene, tile, etc..).
#' @param modelSE A SummarizedExperiment object generated from any modeling function (model_general, model_scRNA, model_scATAC)
#' @param rowName A string, describing the row you want to analyze (tile from scATAC, gene for scRNA, or other from a model_general)
#'
#' @return A data.frame coefficient info by factor. 
#'
#'
#'
#' @examples
#' \dontrun{
#'   age_df <- getModelValues(runZIGLMM_output, 'Chr1:500-999')
#' }
#'
#' @export
#' @keywords model_results
#'

getModelValues <- function(modelSE, rowName){
    
    model_type = isChAIObject(modelSE, type = 'model')

    if(length(rowName) != 1){
      stop('Please provide just one string for rowName, not a list or vector.')
    }

    if(!any(rownames(modelSE) %in% rowName)){
       stop(stringr::str_interp('${rowName} was not modeled within this modelSE provided.'))
    }


    newDF <- do.call('rbind', lapply(as.list(SummarizedExperiment::assays(modelSE)), function(x){
      x[rowName,, drop = FALSE]
    }))
    rownames(newDF) <- names(SummarizedExperiment::assays(modelSE))
    return(newDF)
}



#' @title Get residuals from a given model object
#'
#' @description \code{getResiduals} Takes a model object and returns a SummarizedExperiment containing the residuals for each sample with associated metadata. Useful for modeling residuals.
#' @param modelSE A model object output from any ChAI modeling function (whether on a single modality or the association between two modalities)
#' @return A SummarizedExperiment object. 
#'
#'
#'
#' @examples
#' \dontrun{
#'   getResiduals(modelObj)
#' }
#'
#' @export
#' @keywords model_results
#'

getResiduals <- function(modelSE){
    model_type = isChAIObject(modelSE, type = 'model')
    residDF <- modelSE@metadata$Residuals
    return(residDF)
}


#' @title Get variance decomposition from a model with only random effects
#'
#' @description \code{getVarDecomp} Takes a model object with only random effects and returns variance decomposition results
#' @param modelSE A model object output from any ChAI modeling function (whether on a single modality or the association between two modalities)
#' @return A SummarizedExperiment object. 
#'
#'
#'
#' @examples
#' \dontrun{
#'   getVarDecomp(modelSE)
#' }
#'
#' @export
#' @keywords model_results
#'

getVarDecomp <- function(modelSE) {

    model_type = isChAIObject(modelSE, type = 'model')
    varDF= modelSE@metadata$RandomEffectVariance
    varDF = as.data.frame(varDF/rowSums(varDF))
    varDF$Features = rownames(varDF)
    
    return(varDF)
                               
}

    