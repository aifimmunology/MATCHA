
#' @title Get model predictions, original measurements, and metadata for a given feature
#'
#' @description \code{modelPredictions} Uses the raw data object and the model prediction from a ChAI modeling function to generate a data.frame of raw and predicted features values for plotting.
#' @param dataObject The SummarizedExperiment object with real data. 
#' @param assay1 Name of the assay to analyze
#' @param measurement The specific measurement (gene, motif, tile, protein, etc...) that you want to look at within dataObject
#' @param specVariable The variable(s) of interest. If other fixed effects are present, they will be adjusted for. Must be actual model factors. Use getModelFactors to see the names of model factors in a given model object.
#' @param modelObject a SummarizedOutput object from modelPredict  
#' @param adjust A boolean, default to TRUE. Determines whether to generate an column with an adjusted measurement. The measurement will be adjusted for all factors that are not the specVariable within the model.
#' @param ignoreVariable Default is NULL. use this to specific whether there are any variables that you do not want to adjust for. 
#' @return A summarized experiment where each assay is the data.frame of metadata, original measurement, predicted measurement, and adjusted measurement (option) for each measurement provided. 
#'
#'
#' @export
#' @keywords model_results
#'

modelPredictions <- function(dataObject, assay1, measurement, specVariable, modelObject, adjust = TRUE, ignoreVariable = NULL){
    
    ## Make sure the dataObject is a ChAIObject and then combine so that sample metadata can be pulled out. 
    
    data_type = isChAIObject(dataObject, type = 'data', returnType = TRUE)
    model_type = isChAIObject(modelObject, type = 'model', returnType = TRUE)
    
    logLink <- model_type == 'scRNA_Model'

    
     ##Check data type to make sure dataObject and modelObject match
   if(model_type == 'scRNA_Model' & data_type != 'scRNA'){
        stop('A scRNA model was provided, but the dataObject is not ChAI scRNA object with normalized pseudobulk RNA. Please change the modelObject or the dataObject so that they match.')
                
    }else if(model_type == 'scATAC_Model' & data_type != 'scATAC'){
        stop('A scATAC model was provided but dataObject is not MOCHA SampleTile Object containing pseudobulking scATAC data. Please change the modelObject or the dataObject so that they match.')
                
    }else if(model_type == 'ChromVAR_Model' & data_type != 'ChromVAR'){
        stop('A ChromVAR model was provided, but the dataObject is not a ChAI ChromVAR object, generated by makeChromVAR. Please change the modelObject or the dataObject so that they match.')
                
    }else if(model_type == 'General_Model' & data_type != 'General' ){

        stop('A General model was provided, but the dataObject is not a ChAI General object, from importGeneralModality. Please change the modelObject or the dataObject so that they match.')
        
    }   
        
    ## Need to implement tracking of distributions for model_General
    if(model_type == 'General_Models'){
        warning('modelEstimates does notcurrently support non-Gaussian error distributions when used with model_General.')
    }

    #Test whether the measurement is found within their assays
    if(!all(measurement %in% rownames(dataObject))){
     stop(stringr::str_interp('measurement ${measurement} not found within dataObject. Please read documentation.'))
    }

    if(!all(specVariable %in% getModelFactors(modelObject))){
     stop(stringr::str_interp('One or all of the specVariable(s) ${specVariable} not found within dataObject. Please read documentation.'))
    }
        
        
    ## Extract data and transform it. 
    if(data_type %in% c('scRNA', 'ChromVAR')){
        
        mat1 <- SummarizedExperiment::assays(dataObject[measurement,])[[assay1]] 
        mat1[is.na(mat1)] = 0
        dataObject2 = flattenChAI(dataObject, cellPopulations = assay1, metadataT= TRUE)
        metaData <-  SummarizedExperiment::colData(dataObject2)
        
    } else if(data_type %in% c('scATAC')){

        mat1 <- SummarizedExperiment::assays(dataObject[measurement,])[[assay1]] 
        
        mat1[is.na(mat1)] = 0
        mat1 <- log2(mat1 + 1)
        
        subSTM <- MOCHA::subsetMOCHAObject(dataObject, subsetBy = 'celltype', groupList = assay1)
        dataObject2 = MOCHA::combineSampleTileMatrix(subSTM)
        metaData <-  SummarizedExperiment::colData(dataObject2)
        
    }else {
        
        metaData <-  SummarizedExperiment::colData(dataObject)
        mat1 <- SummarizedExperiment::assays(dataObject[measurement,])[[assay1]] 
        
        mat1[is.na(mat1)] = 0
    }

    #Get a list of metadata information for each sample, and the factors that were used in the model. 
    assayList <- SummarizedExperiment::assays(modelObject)

    allVariables <- names(assayList)[!grepl('ZI_|Intercept',names(assayList))]
    numericVariables <- names(assayList)[names(assayList) %in% colnames(metaData)]
    remainingVariables <- allVariables[!allVariables %in% numericVariables]

    ## Log transform the FragmentNumbers so as to stabilize the model. But only if FragNumber is in the model. Same for CellCounts.
    if(any(colnames(metaData ) %in% c('FragNumber'))){
        metaData$rawFragNumber = metaData$FragNumber
        metaData$FragNumber <- log10(metaData $FragNumber)
    }
    if(any(colnames(metaData ) %in% c('CellCounts'))){
        metaData$rawCellCounts = metaData$CellCounts
        metaData$CellCounts <- log10(metaData $CellCounts)
    }

    #Create a metadata column for each categorical variable, one-hot encoding them. 
    if(length(remainingVariables) > 1){

        nextVariables <- lapply(remainingVariables, function(x) matchCategorical(metaData, x))
        newMetaData = do.call('cbind', nextVariables)
        colnames(newMetaData) <- remainingVariables
        metaData = cbind(metaData, newMetaData)
                                
    }else if(length(remainingVariables) > 0){
        
        newMetaData <- data.frame(newVar = matchCategorical(metaData, remainingVariables))
        colnames(newMetaData) <- remainingVariables
        metaData = cbind(metaData, newMetaData)
        
    }else{
        

    }

    subMeta <- metaData[, colnames(metaData) %in% allVariables]
    if(any(is.na(subMeta))){

        stop('Metadata in dataObject is NA. dataObject is likely not the object used for modeling. Please provide the object used for modeling.')

    }
                                
    allEstimates <- pbapply::pblapply(cl = NULL, seq_along(measurement), function(x){
        
        modelVals <- getModelValues(modelObject, measurement[[x]])[,'Estimate', drop=FALSE]

        newData <- data.frame('exp1' =  unlist(mat1[measurement[[x]],]))

        rownames(newData) = colnames(mat1)
        if(adjust){
            newData$orig_exp1 = newData$exp1
            adjustVariables <- allVariables[! allVariables %in% c(specVariable, ignoreVariable)]
            # Use a dot product to find the model X metadata output. 
            allAdjusts = as.matrix(subMeta[,adjustVariables] ) %*% as.matrix(modelVals[adjustVariables,,drop=FALSE])
            predictVariables <- as.matrix(subMeta[, specVariable, drop = FALSE]) %*% 
                                        as.matrix(modelVals[specVariable, , drop = FALSE])
            # If modeled with a log-link related distribution, then transform after leveraging linearity.
            if(logLink){
                
                logExp1 <- log(newData$exp1) - rowSums(allAdjusts)
                newData$exp1 = exp(logExp1)
                
            }else{
                newData$exp1 = newData$exp1 - rowSums(allAdjusts)
            }
                
            if(any(grepl('Intercept', rownames(modelVals))) & !logLink){
                newData$Prediction = modelVals[grepl('Intercept', rownames(modelVals)),] + 
                                        unlist(as.list(predictVariables))
            }else if(any(grepl('Intercept', rownames(modelVals)))){
                
                newData$Prediction = exp(modelVals[grepl('Intercept', rownames(modelVals)),] + 
                                        unlist(as.list(predictVariables)))
                
            } else{
                newData$Prediction = exp(unlist(as.list(predictVariables)))
            }
            
            if(isChAIObject(dataObject, type = 'data', returnType = TRUE) == 'scATAC'){
                newData$exp1[newData$orig_exp1 ==0] = NA
                newData$Prediction[newData$orig_exp1 ==0] = NA
            }  
        
        }else{
    
            allAdjusts = do.call('cbind',lapply(allVariables[! allVariables %in% c(specVariable, ignoreVariable)], function(x){

                            as.data.frame( modelVals[x,]*as.numeric(subMeta[,x]))

                            }))
            predictVariables <- as.matrix(subMeta[, specVariable, drop = FALSE]) %*% as.matrix(modelVals[specVariable, , drop = FALSE])

            if(any(grepl('Intercept', rownames(modelVals)))){
                newData$Prediction = modelVals[grepl('Intercept', rownames(modelVals)),]  + unlist(as.list(predictVariables)) + sum(colMeans(allAdjusts))
            }else{
                newData$Prediction = unlist(as.list(predictVariables)) + sum(colMeans(allAdjusts))
            }
        
                
            if(logLink){
            
                newData$Prediction = exp(newData$Prediction)
                
            }
            
            if(isChAIObject(dataObject, type = 'data', returnType = TRUE) == 'scATAC'){
                newData$Prediction[newData$exp1 ==0] = NA
            } 
            
        } 

        newData <- cbind(newData, metaData)
        newData
        
    })
        
    names(allEstimates) = measurement
                                
    if(length(measurement) == 1){
    
        return(allEstimates[[1]])
        
    }
    exp = SummarizedExperiment::SummarizedExperiment(allEstimates, metadata = SummarizedExperiment::rowData(dataObject[measurement,]))
   
    return(exp)
}
                                
                                
#' @title transformValues
#'
#' @description \code{.transformModelPrediction} Pull out a data.frame of all model values for a particular row (gene, tile, etc..).
#' @param modelSE A SummarizedExperiment object generated from any modeling function (model_general, model_scRNA, model_scATAC)
#' @param rowName A string, describing the row you want to analyze (tile from scATAC, gene for scRNA, or other from a model_general)
#'
#' @return A data.frame coefficient info by factor. 
#'
#'
#' @noRd
#'
                                
.transformModelPrediction <- function(newData, subMeta, allVariables, specVariable, ignoreVariable, adjust = TRUE){

     if(adjust){
            newData$orig_exp1 = newData$exp1
            adjustVariables <- allVariables[! allVariables %in% c(specVariable, ignoreVariable)]
            # Use a dot product to find the model X metadata output. 
            allAdjusts = as.matrix(modelVals[adjustVariables,,drop=FALSE]) %*% as.matrix(subMeta[,adjustVariables] )
            newData$exp1 = newData$exp1 - rowSums(allAdjusts)
            predictVariables <- as.matrix(subMeta[, specVariable, drop = FALSE]) %*% as.matrix(modelVals[specVariable, , drop = FALSE])
            if(any(grepl('Intercept', rownames(modelVals)))){
                newData$Prediction = modelVals[grepl('Intercept', rownames(modelVals)),] + unlist(as.list(predictVariables))
            }else{
                newData$Prediction = unlist(as.list(predictVariables))
            }

           
        
        }else{
    
            allAdjusts = do.call('cbind',lapply(allVariables[! allVariables %in% c(specVariable, ignoreVariable)], function(x){

                            as.data.frame( modelVals[x,]*as.numeric(subMeta[,x]))

                            }))
            predictVariables <- as.matrix(subMeta[, specVariable, drop = FALSE]) %*% as.matrix(modelVals[specVariable, , drop = FALSE])

            if(any(grepl('Intercept', rownames(modelVals)))){
                newData$Prediction = modelVals[grepl('Intercept', rownames(modelVals)),]  + unlist(as.list(predictVariables)) + sum(colMeans(allAdjusts))
            }else{
                newData$Prediction = unlist(as.list(predictVariables)) + sum(colMeans(allAdjusts))
            }
            
        }
    
}
                                
modelVals <- NULL 

#' @title Get coefficient estimates for all factors, given one feature name
#'
#' @description \code{getModelValues} Pull out a data.frame of all model values for a particular row (gene, tile, etc..).
#' @param modelSE A SummarizedExperiment object generated from any modeling function (model_general, model_scRNA, model_scATAC)
#' @param rowName A string, describing the row you want to analyze (tile from scATAC, gene for scRNA, or other from a model_general)
#'
#' @return A data.frame coefficient info by factor. 
#'
#'
#'
#' @examples
#' \dontrun{
#'   age_df <- getModelValues(runZIGLMM_output, 'Chr1:500-999')
#' }
#'
#' @export
#' @keywords model_results
#'

getModelValues <- function(modelSE, rowName){
    
    model_type = isChAIObject(modelSE, type = 'model')

    if(length(rowName) != 1){
      stop('Please provide just one string for rowName, not a list or vector.')
    }

    if(!any(rownames(modelSE) %in% rowName)){
       stop(stringr::str_interp('${rowName} was not modeled within this modelSE provided.'))
    }


    newDF <- do.call('rbind', lapply(as.list(SummarizedExperiment::assays(modelSE)), function(x){
      x[rowName,, drop = FALSE]
    }))
    rownames(newDF) <- names(SummarizedExperiment::assays(modelSE))
    return(newDF)
}



#' @title Get residuals from a given model object
#'
#' @description \code{getResiduals} Takes a model object and returns a SummarizedExperiment containing the residuals for each sample with associated metadata. Useful for modeling residuals.
#' @param modelObj A model object output from any ChAI modeling function (whether on a single modality or the association between two modalities)
#' @return A SummarizedExperiment object. 
#'
#'
#'
#' @examples
#' \dontrun{
#'   getResiduals(modelObj)
#' }
#'
#' @export
#' @keywords model_results
#'

getResiduals <- function(modelSE){

    resids <- modelSE@metadata$Residuals
    return(residDF)
}
