#' @title \code{GeneTile_Associations} Model Tile accessibility as a function of gene expression
#'
#' @description \code{GeneTile_Associations} High-throughput zero-inflated GLMM-based modeling tile accessibility as a function of gene expression
#' @param atacSE A MOCHA Tile-by-Sample Object (SummarizedExperiment)generated from getSampleTileMatrix within \code{\link[MOCHA]{MOCHA}}. 
#' @param rnaSE A ChAI scRNA object (SummarizedExperiment object) generated by \code{makePseudobulkRNA}
#' @param cellPopulation - name of the assay (cell population) to extract and use from rnaSE and atacSE
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from atacSE and rnaSE. This is used for aligning atacSE and rnaSE
#' @param continuousFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect). 
#'          Exp1 will be the dummy variable for accessibility, while exp2 will be the dummy variable for gene expression. 
#' @param ziFormula list of  to tests from atacSE to test. 
#' @param zi_threshold Zero-inflated threshold ( range = 0-1), representing the fraction of samples with zeros. At or above this threshold, the zero-inflated modeling kicks in.
#'            We don't recommend changing this unless you have fully tested out the model and understand what it is doing. 
#' @param geneList a list of genes from rnaSE to test. 
#' @param tileList optional list of tiles to test. Default is NULL, which will test all tiles within the provided distance of the TSS. 
#' @param distance A number limiting the distance between tiles and genes TSS at which point associations will not be tested. 
#' @param allCombinations A boolean, whether to test all possible pair-wise combinations of geneList and tileList. Default is TRUE. If False, it will require geneList and tileList to be the same length, and only test index-matched pairs (i.e. tileList[2] vs geneList[2] )
#' @param initialSampling An integer. Default is 5. Represents the number of initial models to test when generating a null set (which is used when models fails). If your model fails often, increase this number or choose a better formula.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 1.
#'
#' @return A summarized experiment summarizing the output.
#'
#'  
#'
#' @keywords modeling_associations
#' @export

GeneTile_Associations <- function(atacSE, rnaSE, cellPopulation, sampleColumn, 
                                    continuousFormula, 
                                    ziFormula, 
                                    zi_threshold = 0,
                                    geneList, 
                                    tileList = NULL,
                                    distance = 10^6,
                                    allCombinations = TRUE,
                                    initialSampling = 5, numCores = 2) {
    
 if (!requireNamespace("MOCHA", quietly = TRUE)) {
      stop(
      "Package 'MOCHA' is required for GeneTile_Associations. ",
      "Please install 'MOCHA' to proceed."
      )
  }
    
  tileList <- unique(tileList)
  geneList <- unique(geneList)

  if(isChAIObject(atacSE, type = 'data', returnType = TRUE) != 'scATAC'){

    stop('atacSE is not a SampleTileMatrix Object from MOCHA.')

  }

  if(isChAIObject(rnaSE, type = 'data', returnType = TRUE) != 'scRNA'){

    stop('rnaSE is not a ChAI scRNA Object (normalized, pseudobulked via ChAI.)')

  }
 
  if(!sampleColumn %in% colnames(SummarizedExperiment::colData(atacSE)) |
          !sampleColumn %in% colnames(SummarizedExperiment::colData(rnaSE))){

    stop('sampleColumn missing from atacSE and/or rnaSE.')
  }
    
  ### The sample column must be unique identifiers for aligning samples. 
  ### verify that this is true
  if(any(duplicated(atacSE@colData[,sampleColumn])) | any(duplicated(rnaSE@colData[,sampleColumn]))){
  
      stop('Duplicate values found with sampleColumn provided. Please ensure sample identifiers are unique within each object')
      
  }

    
  #Check whether samples align.     
  if(all(!atacSE@colData[,sampleColumn] %in% rnaSE@colData[,sampleColumn]) |
            all(!rnaSE@colData[,sampleColumn] %in% atacSE@colData[,sampleColumn])){
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in atacSE and rnaSE via ${sampleColumn}.'))
  } else if(!all(rnaSE@colData[,sampleColumn] %in% atacSE@colData[,sampleColumn]) |
      !all(atacSE@colData[,sampleColumn] %in% rnaSE@colData[,sampleColumn])) {
       
       partialMatch <- intersect(rnaSE@colData[,sampleColumn] , 
                                 atacSE@colData[,sampleColumn])
 
      warning(stringr::str_interp('Some samples names in ${sampleColumn} are not the same between modalities. Non-matching names will be dropped'))
      dropped = rnaSE@colData[,sampleColumn] %in% atacSE@colData[,sampleColumn]
      generalDropped = atacSE@colData[,sampleColumn] %in% rnaSE@colData[,sampleColumn]
      warning(stringr::str_interp(' ${sum(!dropped)} and ${sum(!generalDropped)} sample(s) dropped from rnaSE and atacSE, respectively'))

      atacSE <- MOCHA::subsetMOCHAObject(atacSE, subsetBy = sampleColumn, 
                              groupList = partialMatch)
      rnaSE <-  subsetChAI(rnaSE, subsetBy = sampleColumn, 
                              groupList = partialMatch)
    }
 
  #Reorder the samples names so that samples are aligned. 
  if(!all(atacSE@colData[,sampleColumn] == rnaSE@colData[,sampleColumn])){
      message('Reordering rnaSE sample names to match atacSE.')
      rnaOrder = match(atacSE@colData[,sampleColumn], rnaSE@colData[,sampleColumn])
      rnaSE <- rnaSE[,rnaOrder]
      rnaSE@metadata$summarizedData =  rnaSE@metadata$summarizedData[,rnaOrder]
      rnaSE@metadata$detectionRate =  rnaSE@metadata$detectionRate[rnaOrder,]
  }
    
  #Check for samples that had no cells for a given cell type (scRNA) or less than or equal to 5 cells for scATAC.
  emptySamples1 <- unlist(SummarizedExperiment::assays(atacSE@metadata$summarizedData)[['CellCounts']][cellPopulation,]) <= 5
  emptySamples2 <- unlist(SummarizedExperiment::assays(rnaSE@metadata$summarizedData)[['CellCounts']][cellPopulation,]) == 0
                                
  if(any(emptySamples1) | any(emptySamples2)){
    warning(stringr::str_interp('Different number of empty samples across modalities. This can occur when no cells were detected in a given sample of scRNA, or 5 or less in scATACseq. Subsetting will occur now.'))
    atacSamples <- colnames(atacSE)[which(!emptySamples1 | !emptySamples2)]
    rnaSamples <- colnames(rnaSE)[which(!emptySamples1 | !emptySamples2)]
    
    atacSE <- MOCHA::subsetMOCHAObject(atacSE, subsetBy = 'Sample', groupList = atacSamples)
    rnaSE <- subsetChAI(rnaSE, subsetBy = 'Sample', groupList = rnaSamples)
    
  }

  if(any(c(colnames(SummarizedExperiment::colData(atacSE)), 
      colnames(SummarizedExperiment::colData(rnaSE))) %in% c('exp1','exp2'))){

    stop('metadata of atacSE and/or rnaSE contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from atacSE and rnaSE, not the metadata.
    Please remove these and try again.')

  }

   #Test whether tileList and geneList are found in their assays.
  if(!all(geneList %in% rownames(rnaSE))){
     stop('geneList not found within rnaSE. Please read check that your genes of interest are present in rnaSE.')
  }
    
  if (methods::is(continuousFormula,'character')) {
    continuousFormula <- stats::as.formula(continuousFormula)
  }

  if (methods::is(ziFormula, 'character')) {
    ziFormula <- stats::as.formula(ziFormula)
  }

  #Subset down to one cell type
  if (length(cellPopulation) > 1) {
  stop(
    "More than one cell population was provided. ",
    "cellPopulation must be length 1. To run over multiple cell types, ",
    "run combineSampleTileMatrix() to produce a new combined TSAM_Object and set ",
    "cellPopulation = 'counts'."
  )
  } else if (
    (!cellPopulation %in% names(SummarizedExperiment::assays(atacSE)) |
      !cellPopulation %in% names(SummarizedExperiment::assays(rnaSE)))
  ) {
    stop("cellPopulation was not found within atacSE and/or rnaSE.")
  } else if(cellPopulation == 'counts'){
    newatacSE <- atacSE
    newrnaSE <- rnaSE
    
  }else{
    newatacSE <- MOCHA::combineSampleTileMatrix(
                            MOCHA::subsetMOCHAObject(atacSE, 
                                    subsetBy = 'celltype', groupList = cellPopulation, subsetPeaks = TRUE)
                    )
    newrnaSE <- flattenChAI(rnaSE, cellPopulations = cellPopulation)
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newrnaSE <- newrnaSE[rownames(newrnaSE)  %in% unique(geneList), ]
          
  if(!all(tileList %in% rownames(newatacSE)) & !is.null(tileList)){
     stop('tileList not found within atacSE.  Please read check that your tiles of interest are present in atacSE.')
  }else if(is.null(tileList)){
    tileGR <- SummarizedExperiment::rowRanges(newatacSE)
  }else if(length(tileList) > 0){
      
   #if(!MOCHA::validRegionString(tileList)){
      
   #   stop("tileList is a not a valid vector of tile names. Make sure tile names are in the format'ch1:1000-1499'.")
        
   #}
    tileGR <- MOCHA::StringsToGRanges(unique(tileList))
      
  }else{
      
    stop("You provided an empty list of tiles. Please leave tileList as NULL or provide a specific list of tiles in the format 'chr1:1000-1499'")
      
  }

  if(allCombinations){
      geneList <- unique(geneList)
      #Find all tiles within the given distance of the gene list of interest
      geneGR <-SummarizedExperiment::rowRanges(newrnaSE[geneList,])
      if(all(is.null(geneGR))){
              stop('No genomic locations were saved for the ChAI RNA object. Please run linkToGenome on the ChAI RNA object and try again.')
      }
      geneTSS <- GenomicRanges::promoters(geneGR,upstream=1, downstream=1)
      geneWindows <- suppressWarnings(plyranges::stretch(geneTSS, distance*2))

      #Use join_overlap_intersect to find all tiles that overlap with the distance around the TSS. 
      tileGR <- suppressWarnings(expr = plyranges::join_overlap_inner(tileGR, geneWindows))

      #Generate the filtered tile list for those tiles that fall within the distance to the gene. 
      tileList2 <- MOCHA::GRangesToString(tileGR)

      #Generate the data frame of all combinations
      if(length(tileList2) > 0){
          allCombos <- data.frame('Var1' = tileGR$GeneSymbol, 'Var2' = tileList2)
      }else{
      
          stop(stringr::str_interp("No tiles fell within ${distance} bp of a gene within the geneList."))
          
      }

      if(!all(geneList %in% unique(allCombos$Var1))){

          numGenes <- sum(!geneList %in% unique(allCombos$Var1))
          warning(stringr::str_interp("${numGenes} genes do not have any tiles from the tileList within ${distance} basepairs of their tss. These genes have been dropped from testing."))

        }

      if(!all(tileList %in% unique(allCombos$Var2))){

          numTiles <- sum(!tileList %in% unique(allCombos$Var2))
          warning(stringr::str_interp("${numTiles} tiles are not within ${distance} basepairs of a gene's TSS, based on the geneList. These tiles have been dropped from testing."))

        }

      newatacSE <- newatacSE[rownames(newatacSE)  %in% tileList2, ]

    }else if(length(geneList) == length(tileList)){

        allCombos = data.frame(Var1 = geneList, Var2 = tileList)
        newatacSE <- newatacSE[rownames(newatacSE)  %in% unique(tileList), ]

    }else{
  
    stop('Length of tileList and geneList are not the same, so direct pairwise combinations cannot be made. Please set them to be the same length or set allCombinations = TRUE.')
      
  }

  #Test whether the continuousFormula is in the right format
  if(!(all.vars(stats::as.formula(continuousFormula))[1] =='exp1' & any(all.vars(stats::as.formula(continuousFormula)) %in% 'exp2'))){
      
     if(!any(all.vars(stats::as.formula(ziFormula)) %in% 'exp2')){
          
        stop('continuousFormula and/or ziFormula is not in the correct format. Data from rnaSE will be used to predict atacSE, because atacSE is more complicated to model. Please format continuousFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect, and/or include exp2 in the ziFormula.')
    }
  }
    

  if((any(all.vars(stats::as.formula(ziFormula)) %in% 'exp1'))){
    stop('ziFormula is not in the correct format. exp1 represents atac data and should not be in the ziformula. Please format ziFormula as  ~ Factor1 + Factor2 + exp2. This is also optional and can be set to ~0 for non-zero-inflated modeling. ')
  }


  if (zi_threshold < 0 | zi_threshold > 1 | ! is.numeric(zi_threshold)) {
    stop("zi_threshold must be between 0 and 1.")
  }

  message(stringr::str_interp('There are ${length(tileList2)} pairwise combinations of genes and tiles to test.'))
    
  geneTileAssociations <- .multiModalModeling(SE1 = newatacSE, SE2= newrnaSE, 
                            sampleColumn = sampleColumn,
                            allCombos = allCombos, 
                            continuousFormula =  continuousFormula,
                            ziFormula = ziFormula, zi_threshold = zi_threshold, 
                            initialSampling = initialSampling, 
                            family = stats::gaussian(),
                            modality = 'GeneTile',
                            numCores = numCores)

  return(geneTileAssociations)

}

#' @title Model tile accessibility as a function of features counts from a General Modality object
#'
#' @description \code{scATAC_Associations} High-throughput zero-inflated GLMM-based modeling tile accessibility as a function of features from a General Modality
#' @param atacSE A MOCHA Tile-by-Sample Object (SummarizedExperiment)generated from getSampleTileMatrix within \code{\link[MOCHA]{MOCHA}}. 
#' @param cellPopulation - name(s) of the cell population (assay name in the SummarizedExperiment) to be modeled, or the 'all' if you want to model across all cell types.
#' @param generalSE A ChAI General modalityobject, generated by \code{makeChromVAR} or \code{importGeneralModality}
#' @param generalAssay Name of the assay from generalSE that you wish to use for modeling.
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from atacSE and generalSE. This is used for aligning atacSE and generalSE.
#' @param continuousFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect). 
#'          Exp1 will be the dummy variable for accessibility, while exp2 will be the dummy variable for gene expression. 
#' @param ziFormula list of  to tests from atacSE to test. 
#' @param zi_threshold Zero-inflated threshold ( range = 0-1), representing the fraction of samples with zeros. At or above this threshold, the zero-inflated modeling kicks in.
#'            We don't recommend changing this unless you have fully tested out the model and understand what it is doing. 
#' @param tileList a list of tiles to test. 
#' @param generalList A list of which rownames of generalAssay should be used for modeling associations. 
#' @param allCombinations A boolean, whether to test all possible pair-wise combinations of tileList and generalList. Default is TRUE. If False, it will require tileList and generalList to be the same length, and only test index-matched pairs (i.e. tileList[2] vs generalList[2] )
#' @param initialSampling An integer. Default is 5. Represents the number of initial models to test when generating a null set (which is used when models fails). If your model fails often, increase this number or choose a better formula.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 1.
#'
#' @return results a SummarizedExperiment containing modeling results. Assays are metrics related to the model coefficients,
#'          including the Estimate, Std_Error, df, t_value, p_value. Within each assay, each row corresponds to each row of
#'          the SummarizedExperiment and columns correspond to each fixed effect variable within the model.
#'          Any row metadata from the ExperimentObject (see rowData(ExperimentObj)) is preserved in the output. 
#'          The Residual matrix and the variance of the random effects are saved in the metadata slot of the output.
#'          If multiple cell types are provided, then a named list of the above objects will be returned, one for each object. 
#'
#'  
#'
#' @keywords modeling_associations
#' @export


scATAC_Associations <- function(atacSE, cellPopulation, 
                                    generalSE, generalAssay,
                                    sampleColumn, 
                                    continuousFormula, 
                                    ziFormula = ~ 0 + FragmentCounts, 
                                    zi_threshold = 0,
                                    tileList,
                                    generalList, 
                                    allCombinations = TRUE,
                                    initialSampling = 5, numCores = 2) {
 
   if (!requireNamespace("MOCHA", quietly = TRUE)) {
      stop(
      "Package 'MOCHA' is required for GeneTile_Associations. ",
      "Please install 'MOCHA' to proceed."
      )
  }

  if(isChAIObject(atacSE, type = 'data', returnType = TRUE) != 'scATAC'){

    stop('atacSE is not a SampleTileMatrix Object from MOCHA.')

  }

  if(!isChAIObject(generalSE, type = 'data', returnType = TRUE) %in% c('General', 'ChromVAR')){

    stop('generalSE is neither a ChAI General Modality Object, generated via importGeneralModality, 
            nor a ChAI ChromVAR object generated by makeChromVAR.')

  }
 
  if(!sampleColumn %in% colnames(SummarizedExperiment::colData(atacSE)) |
          !sampleColumn %in% colnames(SummarizedExperiment::colData(generalSE))){

    stop('sampleColumn missing from atacSE and/or generalSE.')
  }
    
    
  ### The sample column must be unique identifiers for aligning samples. 
  ### verify that this is true
  if(any(duplicated(atacSE@colData[,sampleColumn])) | any(duplicated(generalSE@colData[,sampleColumn]))){
  
      stop('Duplicate values found with sampleColumn provided. Please ensure sample identifiers are unique within each object')
      
  }
    
 #Check whether samples align.     
 if(all(!atacSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]) |
      all(!generalSE@colData[,sampleColumn] %in% atacSE@colData[,sampleColumn])) {
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in generalSE and atacSE via ${sampleColumn}.'))
  } else if(!all(atacSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]) |
      !all(generalSE@colData[,sampleColumn] %in% atacSE@colData[,sampleColumn])) {
       
       partialMatch <- intersect(atacSE@colData[,sampleColumn] , 
                                 generalSE@colData[,sampleColumn])
 
      warning(stringr::str_interp('Some samples names in ${sampleColumn} are not the same between modalities. Non-matching names will be dropped'))
      dropped = atacSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]
      generalDropped = generalSE@colData[,sampleColumn] %in% atacSE@colData[,sampleColumn]
      warning(stringr::str_interp(' ${sum(!dropped)} and ${sum(!generalDropped)} sample(s) dropped from atacSE and generalSE, respectively'))

      generalSE <- subsetChAI(generalSE, subsetBy = sampleColumn, 
                              groupList = partialMatch)
      atacSE <-  MOCHA::subsetMOCHAObject(atacSE, subsetBy = sampleColumn, 
                              groupList = partialMatch)
    }
 
 if(!all(atacSE@colData[,sampleColumn] == generalSE@colData[,sampleColumn])){

      message('Reordering generalSE sample names to match atacSE.')
      generalSE <- generalSE[,order(generalSE@colData[,sampleColumn])]
     
      atacOrder = order(atacSE@colData[,sampleColumn])
      atacSE <- atacSE[,atacOrder]
      atacSE@metadata$summarizedData = atacSE@metadata$summarizedData[,atacOrder]
      atacSE@metadata$detectionRate =  atacSE@metadata$detectionRate[atacOrder,]

  }
     
 ## Check whether all tiles are present in the atacSE object.
  if(!all(tileList %in% rownames(atacSE))){
     stop('tileList not found within atacSE.  Please read check that your tiles of interest are present in atacSE.')
  }
     

  if(any(c(colnames(SummarizedExperiment::colData(atacSE)), 
      colnames(SummarizedExperiment::colData(generalSE))) %in% c('exp1','exp2'))){

    stop('metadata of atacSE and/or generalSE contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from atacSE and generalSE, not the metadata.
    Please remove these and try again.')

  }

   #Test whether tileList and geneList are found in their assays.
  if(!all(generalList %in% rownames(generalSE))){
     stop('generalList not found within generalSE. Please read check that your genes of interest are present in generalSE.')
  }
    
  if (methods::is(continuousFormula, 'character')) {
    continuousFormula <- stats::as.formula(continuousFormula)
  }

  if (methods::is(ziFormula,'character')) {
    ziFormula <- stats::as.formula(ziFormula)
  }
  
    
  ## Evaluate cellPopulations. 
  if(all(tolower(cellPopulation) == 'all')){
   
      cellPopulation = SummarizedExperiment::assayNames(atacSE)
      
  }
    
      
  if(!all(cellPopulation %in% SummarizedExperiment::assayNames(atacSE))){
   
      stop('cellPopulation not found within atacSE object')
      
  }
      
  #If multiple cell types, then loop over all and return a list of model objects. 
  if(length(cellPopulation) > 1){
    
    allRes = lapply(cellPopulation, function(XX){
            message(stringr::str_interp('Modeling ${XX}'))
            tryCatch({
                gc()
                subTiles = getCellTypeTiles(atacSE[tileList,], cellType = XX)
                if(length(subTiles) > 0){
                    scATAC_Associations(atacSE, cellPopulation = XX,
                                        generalSE, generalAssay,
                                        sampleColumn, 
                                        continuousFormula, 
                                        ziFormula = ziFormula, 
                                        zi_threshold = zi_threshold,
                                        tileList,
                                        generalList, 
                                        allCombinations = allCombinations,
                                        initialSampling = initialSampling, 
                                        numCores = numCores)
                } else{ return('No tiles called for this celltype') }
                
                }, error = function(e){e})
        })
    names(allRes) = cellPopulation
    return(allRes)
    
  } else if(cellPopulation == 'counts'){
    
    newatacSE <- atacSE
    #Check for samples that had no cells for a given cell type (scRNA) or less than or equal to 5 cells for scATAC.
    emptySamples1 <- newatacSE$CellCounts <= 5
     if(any(emptySamples1)){
        
        warning(stringr::str_interp('Different number of empty samples across modalities. This can occur when no cells were detected
                    in a given sample of scRNA, or 5 or less in scATACseq. Subsetting will occur now.'))
        newatacSE=newatacSE[,!emptySamples1]
        generalSamples <- colnames(generalSE)[which(!emptySamples1)]

        generalSE <- subsetChAI(generalSE, subsetBy = 'Sample', groupList = generalSamples)

    }

    
  } else{
    
    #Check for samples that had no cells for a given cell type (scRNA) or less than or equal to 5 cells for scATAC.
    emptySamples1 <- unlist(SummarizedExperiment::assays(atacSE@metadata$summarizedData)[['CellCounts']][cellPopulation,]) <= 5

    if(any(emptySamples1)){
        
        warning(stringr::str_interp('Different number of empty samples across modalities. This can occur when no cells were detected
                    in a given sample of scRNA, or 5 or less in scATACseq. Subsetting will occur now.'))
        atacSamples <- colnames(atacSE)[which(!emptySamples1)]
        generalSamples <- colnames(generalSE)[which(!emptySamples1)]

        atacSE <- MOCHA::subsetMOCHAObject(atacSE, subsetBy = 'Sample', groupList = atacSamples)
        generalSE <- subsetChAI(generalSE, subsetBy = 'Sample', groupList = generalSamples)

    }

    newatacSE <- MOCHA::combineSampleTileMatrix(MOCHA::subsetMOCHAObject(atacSE, subsetBy = 'celltype', groupList = cellPopulation, subsetPeaks = TRUE))
    
  }
  newGeneral <- generalSE
  SummarizedExperiment::assays(newGeneral) <- SummarizedExperiment::assays(newGeneral)[generalAssay]

    #Test whether the continuousFormula is in the right format
  if(!(all.vars(stats::as.formula(continuousFormula))[1] =='exp1' & any(all.vars(stats::as.formula(continuousFormula)) %in% 'exp2'))){
      
     if(!any(all.vars(stats::as.formula(ziFormula)) %in% 'exp2')){
          
        stop('continuousFormula and/or ziFormula is not in the correct format. Please format continuousFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect, and/or include exp2 in the ziFormula.')
    }
  }

  if((any(all.vars(stats::as.formula(ziFormula)) %in% 'exp1'))){
    stop('ziFormula is not in the correct format. exp1 represents atac data and should not be in the ziformula. Please format ziFormula as  ~ Factor1 + Factor2 + exp2. This is also optional and can be set to ~0 for non-zero-inflated modeling. ')
  }


  if (zi_threshold < 0 | zi_threshold > 1 | ! is.numeric(zi_threshold)) {
    stop("zi_threshold must be between 0 and 1.")
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newatacSE <- newatacSE[rownames(newatacSE)  %in% unique(tileList), ]
  newGeneral <- newGeneral[rownames(newGeneral)  %in% unique(generalList), ]
    
  #Find all combinations of tileList and geneList to test.
  message('Compiling pair-wise combinations')

  if(allCombinations){
    tileList <- unique(tileList)
    generalList <- unique(generalList)
    #Find all combinations of tileList and geneList to test. 
    cl <- parallel::makeCluster(numCores)
    allCombos <- do.call('rbind', pbapply::pblapply(cl = cl, X = generalList, findCombo, List2 = tileList))
    parallel::stopCluster(cl)
    }else if(length(generalList) == length(tileList)){

        allCombos = data.frame(Var1 = generalList, Var2 = tileList)

    }else{
  
    stop('Length of tileList and generalList are not the same, so direct pairwise combinations cannot be made. Please set them to be the same length or set allCombinations = TRUE.')
      
  }


  scATAC_Assoc <- .multiModalModeling(SE1 = newatacSE, SE2 = newGeneral, sampleColumn = sampleColumn,
                          allCombos = allCombos, continuousFormula =  continuousFormula,
                        ziFormula = ziFormula, zi_threshold = zi_threshold, 
                                      initialSampling = initialSampling, 
                        family = stats::gaussian(), modality = 'scATAC_Associations',
                        numCores = numCores)

  return(scATAC_Assoc)

}

#' @title \code{findCombo}
#'
#' @description \code{findCombo}
#'
#' @description \code{findCombo} helper
#' @param x specif
#'
#' @return A data.frame of combinations
#'
#' @noRd
#'
findCombo <- function(x, List2){
    as.data.frame(expand.grid(as.character(x),as.character(List2)), stringsAsFactors = FALSE)
  }



#' @title \code{scRNA_Associations} Model gene expression as a function of features counts from a General Modality object
#'
#' @description \code{scRNA_Associations} High-throughput GLMM-based modeling to associate gene expression to another modality, while controlling for technical confounders
#' @param rnaSE A ChAI scRNA object (SummarizedExperiment object) generated by \code{makePseudobulkRNA}
#' @param cellPopulation - name of the assay (cell population) to extract and use from rnaSE and atacSE
#' @param generalSE A ChAI General modalityobject, generated by \code{makeChromVAR} or \code{importGeneralModality}
#' @param generalAssay Name of the assay from generalSE that you wish to use for modeling.
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from atacSE and rnaSE. This is used for aligning atacSE and rnaSE
#' @param modelFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect), where 
#'          exp1 is the dummy variable for gene expression and exp2 is the dummy variable for the rownames from generalSE. 
#' @param ziFormula list of  to tests from atacSE to test. 
#' @param family String. Can be 'negativeBinomial1', 'negativeBinomial2', or 'poisson'. Default is "negativeBinomial2". 
#' @param cellCountThreshold The minimum number of cells in a given pseudobulk for the pseudobulk to be included in analysis. If fewer than this number of cells are found, then the sample will be dicarded The number of cells within the pseudobulked scRNA. Default is 10 cells. 
#' @param geneList a list of genes from rnaSE to test. 
#' @param generalList A list of which rownames of generalAssay should be used for modeling associations. 
#' @param allCombinations A boolean, whether to test all possible pair-wise combinations of geneList and generalList. Default is TRUE. If False, it will require geneList and generalList to be the same length, and only test index-matched pairs (i.e. geneList[2] vs generalList[2] )
#' @param initialSampling An integer. Default is 5. Represents the number of initial models to test when generating a null set (which is used when models fails). If your model fails often, increase this number or choose a better formula.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 2.
#'
#' @return results a SummarizedExperiment containing modeling results. Assays are metrics related to the model coefficients,
#'          including the Estimate, Std_Error, df, t_value, p_value. Within each assay, each row corresponds to each row of
#'          the SummarizedExperiment and columns correspond to each fixed effect variable within the model.
#'          Any row metadata from the ExperimentObject (see rowData(ExperimentObj)) is preserved in the output. 
#'          The Residual matrix and the variance of the random effects are saved in the metadata slot of the output.
#'          If multiple cell types are provided, then a named list of the above objects will be returned, one for each object. 
#'
#'  
#'
#' @keywords modeling_associations
#' @export

scRNA_Associations <- function(rnaSE, cellPopulation, 
                                    generalSE, generalAssay,
                                    sampleColumn, 
                                    modelFormula, 
                                    ziFormula = ~0,
                                    cellCountThreshold = 10,
                                    family = "negativeBinomial2",
                                    geneList, 
                                    generalList = NULL,
                                    allCombinations = TRUE,
                                    initialSampling = 5, numCores = 2) {
                                      
  if(isChAIObject(rnaSE, type = 'data', returnType = TRUE) != 'scRNA'){

    stop('rnaSE is not a ChAI scRNA object.')

  }

 if(!isChAIObject(generalSE, type = 'data', returnType = TRUE) %in% c('General', 'ChromVAR')){

    stop('generalSE is neither a ChAI General Modality Object, generated via importGeneralModality, 
            nor a ChAI ChromVAR object generated by makeChromVAR.')

  }
    
  if(!sampleColumn %in% colnames(SummarizedExperiment::colData(generalSE)) |
          !sampleColumn %in% colnames(SummarizedExperiment::colData(rnaSE))){

    stop('sampleColumn missing from generalSE and/or rnaSE.')
  }
    
    
  ### The sample column must be unique identifiers for aligning samples. 
  ### verify that this is true
  if(any(duplicated(generalSE@colData[,sampleColumn])) | any(duplicated(rnaSE@colData[,sampleColumn]))){
  
      stop('Duplicate values found with sampleColumn provided. Please ensure sample identifiers are unique within each object')
      
  }
    
       
  #Check whether samples align.     
  if(all(!generalSE@colData[,sampleColumn] %in% rnaSE@colData[,sampleColumn]) |
            all(!rnaSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn])){
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in generalSE and rnaSE via ${sampleColumn}.'))
  } else if(!all(rnaSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]) |
      !all(generalSE@colData[,sampleColumn] %in% rnaSE@colData[,sampleColumn])) {
       
       partialMatch <- intersect(rnaSE@colData[,sampleColumn] , 
                                 generalSE@colData[,sampleColumn])
 
      warning(stringr::str_interp('Some samples names in ${sampleColumn} are not the same between modalities. Non-matching names will be dropped'))
      dropped = rnaSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]
      generalDropped = generalSE@colData[,sampleColumn] %in% rnaSE@colData[,sampleColumn]
      warning(stringr::str_interp(' ${sum(!dropped)} and ${sum(!generalDropped)} sample(s) dropped from rnaSE and generalSE, respectively'))

      generalSE <- subsetChAI(generalSE, subsetBy = sampleColumn, 
                              groupList = partialMatch)
      rnaSE <-  subsetChAI(rnaSE, subsetBy = sampleColumn, 
                              groupList = partialMatch)
    }


  if(!all(generalSE@colData[,sampleColumn] == rnaSE@colData[,sampleColumn])){
      message('Re-ordering rnaSE and generalSE to match.')
      rnaOrder = order(rnaSE@colData[,sampleColumn])
      rnaSE <- rnaSE[,rnaOrder]
      rnaSE@metadata$summarizedData =  rnaSE@metadata$summarizedData[,rnaOrder]
      rnaSE@metadata$detectionRate =  rnaSE@metadata$detectionRate[rnaOrder,]
      generalSE <- generalSE[,order(generalSE@colData[,sampleColumn])]
  }
      
  if(all(tolower(cellPopulation) == 'all')){
   
      cellPopulation = SummarizedExperiment::assayNames(rnaSE)
      
  }
      
  if(!all(cellPopulation %in% SummarizedExperiment::assayNames(rnaSE))){
   
      stop('cellPopulation not found within rnaSE object')
      
  }

      
  #If multiple cell types, then loop over all and return a list of model objects. 
  if(length(cellPopulation) > 1){
    
    allRes = lapply(cellPopulation, function(XX){
            message(stringr::str_interp('Modeling ${XX}'))
            tryCatch({
                gc()
                if(all(names(geneList) %in% cellPopulation) & all(!is.null(names(geneList)))){
                    subgeneList = geneList[[XX]]
                }else{
                    
                    subgeneList = geneList
                }

               if(all(names(generalList) %in% cellPopulation) & all(!is.null(names(generalList)))){
                    subGeneral = generalList[[XX]]
                }else{
                    
                    subGeneral = generalList
                }
                
                scRNA_Associations(rnaSE, cellPopulation = XX, 
                        generalSE, generalAssay,
                        sampleColumn, 
                        modelFormula, 
                        ziFormula = ziFormula,
                        cellCountThreshold = cellCountThreshold,
                        family = family,
                        geneList =subgeneList, 
                        generalList = subGeneral,
                        allCombinations = allCombinations,
                        initialSampling = initialSampling, numCores = numCores)
            }, error = function(e){e})
        })
    names(allRes) = cellPopulation
    return(allRes)
    
  }
      
  #Check for samples that had no cells for a given cell type (scRNA) or less than or equal to 5 cells for scATAC.
  emptySamples1 <- unlist(SummarizedExperiment::assays(rnaSE@metadata$summarizedData)[['CellCounts']][cellPopulation,]) < cellCountThreshold
                 
  if(any(emptySamples1)){
    warning(stringr::str_interp('Different number of empty samples across modalities. This can occur when no cells were detected in a given sample of scRNA, or 5 or less in scATACseq. Subsetting will occur now.'))
    rnaSamples <- SummarizedExperiment::colData(rnaSE)[which(!emptySamples1), sampleColumn]
      
    generalSE <- subsetChAI(generalSE, subsetBy = sampleColumn, 
                              groupList = rnaSamples)
    rnaSE <-  subsetChAI(rnaSE, subsetBy = sampleColumn, 
                              groupList = rnaSamples)
    
  }
    
  if(dim(rnaSE)[1] <3 | dim(generalSE)[1] < 3){
   
      stop('Too little overlap in samples between rnaSE and generalSE')
      
   }

  if(any(c(colnames(SummarizedExperiment::colData(generalSE)), 
      colnames(SummarizedExperiment::colData(rnaSE))) %in% c('exp1','exp2'))){

    stop('metadata of generalSE and/or rnaSE contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from generalSE and rnaSE, not the metadata.
    Please remove these and try again.')

  }

   #Test whether generalList and geneList are found in their assays.
  if(!all(geneList %in% rownames(rnaSE))){
     stop('geneList not found within rnaSE. Please read check that your genes of interest are present in rnaSE.')
  }
  if(!all(generalList %in% rownames(generalSE))){
     stop('generalList not found within generalSE.R Please double check generalList and generalSE rownames.')
  }
    
    
  if (methods::is(modelFormula, 'character')) {
    modelFormula <- stats::as.formula(modelFormula)
  }else if(!methods::is(modelFormula,'formula')){
    stop('modelFormula is neither a string describing a formula, nor a formula itself. Please provide one of these formats.')
  }

  #Subset down to one cell type
  if (length(cellPopulation) > 1) {
  stop(
    "More than one cell population was provided. ",
    "cellPopulation must be length 1. To run over multiple cell types, ",
    "run combineSampleTileMatrix() to produce a new combined TSAM_Object and set ",
    "cellPopulation = 'counts'."
  )
  } else if (
    (!generalAssay %in% names(SummarizedExperiment::assays(generalSE)) |
      !cellPopulation %in% names(SummarizedExperiment::assays(rnaSE)))
  ) {
    stop("cellPopulation was not found within rnaSE and/or generalAssay within generalSE.")
  } else if(cellPopulation == 'counts'){
    newrnaSE <- rnaSE
    
  }else{
    newrnaSE <- flattenChAI(rnaSE, cellPopulations = cellPopulation)
  }

  newGeneral <- generalSE
  SummarizedExperiment::assays(newGeneral) <- SummarizedExperiment::assays(newGeneral)[generalAssay]


  #Test whether the continuousFormula is in the right format
  if(!(all.vars(stats::as.formula(modelFormula))[1] =='exp1' & any(all.vars(stats::as.formula(modelFormula)) %in% 'exp2'))){
    stop('modelFormula is not in the correct format. Data from generalSE will be used to predict rnaSE, because rnaSE is more complicated to model. Please format modelFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect.')
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newGeneral <- newGeneral[rownames(newGeneral)  %in% unique(generalList), ]
  newrnaSE <- newrnaSE[rownames(newrnaSE)  %in% unique(geneList), ]
    
   if(sum(newrnaSE$CellCounts >=  cellCountThreshold) < 3){

      stop('Fewer than 3 samples passed the CellCounts threshold. Modeling not possible.')

  }else if(any(!newrnaSE$CellCounts >=  cellCountThreshold)){

      ## Filter both modalities down to samples with enough cells for modeling. 
      message(stringr::str_interp('${sum(!newrnaSE$CellCounts >=  cellCountThreshold)} Samples removed due to cell counts below cellCountThreshold'))
      newGeneral <- newGeneral[,newrnaSE$CellCounts >=  cellCountThreshold]
      newrnaSE <- newrnaSE[,newrnaSE$CellCounts >=  cellCountThreshold]
      
  }
    

  if(all(tolower(family) == 'negativebinomial2')){ 
    family = glmmTMB::nbinom2()
  }else if(all(tolower(family)== 'negativebinomial1')){
    family = glmmTMB::nbinom1()
  }else if(all(tolower(family) == 'poisson')){
    family = stats::poisson()
  }else{
    stop('family not recognized.')
  }
      
  if (methods::is(ziFormula, 'character')) {
    ziFormula <- stats::as.formula(ziFormula)
  }


  if((any(all.vars(stats::as.formula(ziFormula)) %in% 'exp1'))){
    stop('ziFormula is not in the correct format. exp1 represents rna data and should not be in the ziformula. Please format ziFormula as  ~ Factor1 + Factor2 + exp2. This is also optional and can be set to ~0 for non-zero-inflated modeling. ')
  }


  #Find all combinations of generalList and geneList to test.
  message('Compiling all pair-wise combinations')

  if(allCombinations){
    geneList <- unique(geneList)
    generalList <- unique(generalList)
      
    cl <- parallel::makeCluster(numCores)

    allCombos <- do.call('rbind', pbapply::pblapply(cl = cl, X = generalList, findCombo, List2 = geneList))
    parallel::stopCluster(cl)
      
  }else if(length(generalList) == length(geneList)){

    allCombos = data.frame(Var1 = generalList, Var2 = geneList)

  }else{
  
    stop('Length of generalList and geneList are not the same, so direct pairwise combinations cannot be made. Please set them to be the same length or set allCombinations = TRUE.')
      
  }
      
      
  geneAssociations <- .multiModalModeling(SE1 = newrnaSE, SE2=  newGeneral, 
                        sampleColumn =  sampleColumn, 
                        allCombos = allCombos, 
                        continuousFormula = modelFormula,
                        ziFormula = ziFormula, zi_threshold = 0, initialSampling = initialSampling,
                        family = family,
                        modality = 'scRNA_Associations',
                        numCores = numCores)

  return(geneAssociations)

}




#' @title \code{ChromVAR_Associations} Model ChromVAR Z-scores as a function of features counts from a General Modality object
#'
#' @description \code{ChromVAR_Associations} High-throughput modeling motif z-score changes as a function of a feature from a General Modality
#' @param chromSE A ChAI ChromVAR object (SummarizedExperiment object) from \code{makeChromVAR}
#' @param cellPopulation - name(s) of the assay (cell population) to extract and use from chromSE, or the string 'All' if you want to model across all celltypes
#' @param generalSE A ChAI General modalityobject, generated by \code{makeChromVAR} or \code{importGeneralModality}
#' @param generalAssay Name of the assay from generalSE that you wish to use for modeling.
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from chromSE and generalSE. This is used for aligning chromSE and generalSE.
#' @param modelFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect). 
#'          Exp1 will be the dummy variable for Motif Z-score, while exp2 will be the dummy variable for the general assay.
#' @param motifList a list of motifs to test
#' @param generalList A list of which rownames of generalAssay should be used for modeling associations. 
#' @param allCombinations A boolean, whether to test all possible pair-wise combinations of tileList and generalList. Default is TRUE. If False, it will require tileList and generalList to be the same length, and only test index-matched pairs (i.e. tileList[2] vs generalList[2] )
#' @param initialSampling An integer. Default is 5. Represents the number of initial models to test when generating a null set (which is used when models fails). If your model fails often, increase this number or choose a better formula.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 1.
#'
#' @return results a SummarizedExperiment containing modeling results. Assays are metrics related to the model coefficients,
#'          including the Estimate, Std_Error, df, t_value, p_value. Within each assay, each row corresponds to each row of
#'          the SummarizedExperiment and columns correspond to each fixed effect variable within the model.
#'          Any row metadata from the ExperimentObject (see rowData(ExperimentObj)) is preserved in the output. 
#'          The Residual matrix and the variance of the random effects are saved in the metadata slot of the output.
#'          If multiple cell types are provided, then a named list of the above objects will be returned, one for each object. 
#'
#'  
#'
#'
#' @export
#' @keywords modeling_associations


ChromVAR_Associations <- function(chromSE, cellPopulation, 
                                    generalSE, generalAssay,
                                    sampleColumn, 
                                    modelFormula, 
                                    motifList,
                                    generalList, 
                                    allCombinations = TRUE,
                                    initialSampling = 5, numCores = 2) {
 
  if (!requireNamespace("MOCHA", quietly = TRUE)) {
      stop(
      "Package 'MOCHA' is required for GeneTile_Associations. ",
      "Please install 'MOCHA' to proceed."
      )
  }

  if(isChAIObject(chromSE, type = 'data', returnType = TRUE) != 'ChromVAR'){

    stop('chromSE is not a ChAI ChromVAR Object, generated via makeChromVAR.')

  }

  if(!isChAIObject(generalSE, type = 'data', returnType = TRUE) %in% c('General','ChromVAR')){

    stop('generalSE is neither a ChAI General Modality Object, generated via importGeneralModality, 
            nor a ChAI ChromVAR Object, generated by makeChromVAR.')

  }
 
  if(!sampleColumn %in% colnames(SummarizedExperiment::colData(chromSE)) |
          !sampleColumn %in% colnames(SummarizedExperiment::colData(generalSE))){

    stop('sampleColumn missing from chromSE and/or generalSE.')
  }
    
    
  ### The sample column must be unique identifiers for aligning samples. 
  ### verify that this is true
  if(any(duplicated(generalSE@colData[,sampleColumn])) | any(duplicated(chromSE@colData[,sampleColumn]))){
  
      stop('Duplicate values found with sampleColumn provided. Please ensure sample identifiers are unique within each object')
      
  }

  #Check whether samples align.     
   if(all(!chromSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]) |
      all(!generalSE@colData[,sampleColumn] %in% chromSE@colData[,sampleColumn])) {
 
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in generalSE and chromSE via ${sampleColumn}.'))
 
  }else if(!all(chromSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]) |
      !all(generalSE@colData[,sampleColumn] %in% chromSE@colData[,sampleColumn])) {
       
       partialMatch <- intersect(generalSE@colData[,sampleColumn] , 
                                 chromSE@colData[,sampleColumn])
 
      warning(stringr::str_interp('Some samples names in ${sampleColumn} are not the same between modalities. Non-matching names will be dropped'))
      chromDropped = chromSE@colData[,sampleColumn] %in% generalSE@colData[,sampleColumn]
      generalDropped = generalSE@colData[,sampleColumn] %in% chromSE@colData[,sampleColumn]
      warning(stringr::str_interp(' ${sum(!chromDropped)} and ${sum(!generalDropped)} sample(s) dropped from chromSE and generalSE, respectively'))

      generalSE <- subsetChAI(generalSE, subsetBy = sampleColumn, 
                              groupList = partialMatch)
      chromSE <-  subsetChAI(chromSE, subsetBy = sampleColumn, 
                              groupList = partialMatch)
    }

  if(!all(chromSE@colData[,sampleColumn] == generalSE@colData[,sampleColumn])){

      message('Re-ordering generalSE sample names to match chromSE.')
      generalSE <- generalSE[,order(generalSE@colData[,sampleColumn])]
      chromOrder = order(chromSE@colData[,sampleColumn])
      chromSE <- chromSE[,chromOrder]
      chromSE@metadata$summarizedData =  chromSE@metadata$summarizedData[,chromOrder]
      chromSE@metadata$detectionRate =  chromSE@metadata$detectionRate[chromOrder,]
  }
       
       
   if(all(tolower(cellPopulation) == 'all')){
   
      cellPopulation = SummarizedExperiment::assayNames(chromSE)
      
  }
      
  if(!all(cellPopulation %in% SummarizedExperiment::assayNames(chromSE))){
   
      stop('cellPopulation not found within rnaSE object')
      
  }
      
  #If multiple cell types, then loop over all and return a list of model objects. 
  if(length(cellPopulation) > 1){
    
    allRes = lapply(cellPopulation, function(XX){
            message(stringr::str_interp('Modeling ${XX}'))
            tryCatch({
                gc()
                
                if(all(names(motifList) %in% cellPopulation) & all(!is.null(names(motifList)))){
                    subMotifs = motifList[[XX]]
                }else{
                    
                    subMotifs = motifList
                }
                
                 if(all(names(generalList) %in% cellPopulation)  & all(!is.null(names(generalList)))){
                    subGeneral = generalList[[XX]]
                }else{
                    
                    subGeneral = generalList
                }
                
                ChromVAR_Associations(chromSE, cellPopulation = XX, 
                        generalSE, generalAssay,
                        sampleColumn, 
                        modelFormula, 
                        motifList = subMotifs,
                        generalList = subGeneral, 
                        allCombinations = allCombinations,
                        initialSampling = initialSampling, numCores = numCores)
            }, error = function(e){e})
        })
    names(allRes) = cellPopulation
    return(allRes)
    
  }
       
  #Check for samples that had no cells for a given cell type (scRNA) or less than or equal to 5 cells for scATAC/ChromVAR.
  emptySamples1 <- unlist(SummarizedExperiment::assays(chromSE@metadata$summarizedData)[['CellCounts']][cellPopulation,]) <= 5
                                
  if(any(emptySamples1)){
    warning(stringr::str_interp('Different number of empty samples across modalities. This can occur when no cells were detected in a given sample of scRNA, or 5 or less in scATACseq. Subsetting will occur now.'))
    chromSamples <- colnames(chromSE)[which(!emptySamples1)]
    generalSamples <- colnames(generalSE)[which(!emptySamples1)]
    
    chromSE <- subsetChAI(chromSE, subsetBy = 'Sample', groupList = chromSamples)
    generalSE <- subsetChAI(generalSE, subsetBy = 'Sample', groupList = generalSamples)
    
  }

  if(any(c(colnames(SummarizedExperiment::colData(chromSE)), 
      colnames(SummarizedExperiment::colData(generalSE))) %in% c('exp1','exp2'))){

    stop('metadata of chromSE and/or generalSE contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from chromSE and generalSE, not the metadata.
    Please remove these and try again.')

  }
      
   #Test whether motifList and geneList are found in their assays.
  if(!all(generalList %in% rownames(generalSE))){
     stop('generalList not found within generalSE. Please read check that your genes of interest are present in generalSE.')
  }
    
  if (methods::is(modelFormula, 'character')) {
    modelFormula <- stats::as.formula(modelFormula)
  }


  #Subset down to one cell type
  if (length(cellPopulation) > 1) {
  stop(
    "More than one cell population was provided. ",
    "cellPopulation must be length 1. To run over multiple cell types, ",
    "run flattenChAI() to produce a new ChAI object that is combined across celltypes and set ",
    "cellPopulation = 'counts'."
  )
  } else if (!cellPopulation %in% names(SummarizedExperiment::assays(chromSE))){
    stop(stringr::str_interp("!{cellPopulation} was not found within chromSE."))
  } else if ( !generalAssay %in% names(SummarizedExperiment::assays(generalSE))){
     stop(stringr::str_interp("!{generalAssay} was not found within generalSE."))

  } else{
    newchromSE <- flattenChAI(chromSE, cellPopulations = cellPopulation)
   
  }
  newGeneral <- generalSE
  SummarizedExperiment::assays(newGeneral) <- SummarizedExperiment::assays(newGeneral)[generalAssay]

  if(!all(motifList %in% rownames(newchromSE))){
     stop('motifList not found within chromSE.  Please read check that your tiles of interest are present in chromSE.')
  }


  #Test whether the modelFormula is in the right format
  if(!(all.vars(stats::as.formula(modelFormula))[1] =='exp1' & any(all.vars(stats::as.formula(modelFormula)) %in% 'exp2'))){
    stop('modelFormula is not in the correct format. Data from generalSE will be used to predict chromSE, because chromSE is more complicated to model. Please format modelFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect.')
  }

  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newchromSE <- newchromSE[rownames(newchromSE)  %in% unique(motifList), ]
  newGeneral <- newGeneral[rownames(newGeneral)  %in% unique(generalList), ]

  #Find all combinations of tileList and geneList to test.
  message('Compiling all pair-wise combinations')
  
  if(allCombinations){
    motifList <- unique(motifList)
    generalList <- unique(generalList)
      #Find all combinations of tileList and motifList to test. 
      cl <- parallel::makeCluster(numCores)
    allCombos <- do.call('rbind', pbapply::pblapply(cl = cl, X = generalList, findCombo, List2 = motifList))
      parallel::stopCluster(cl)
      
  }else if(length(generalList) == length(motifList)){

    allCombos = data.frame(Var1 = generalList, Var2 = motifList)

  }else{
      
      stop('Length of generalList and motifList are not the same, so direct pairwise combinations cannot be made. Please set them to be the same length or set allCombinations = TRUE.')
  }
      


  chromSE_Assoc <- .multiModalModeling(SE1 = newchromSE, SE2 = newGeneral, sampleColumn = sampleColumn,
                          allCombos = allCombos, continuousFormula =  modelFormula,
                        ziFormula = ~0, zi_threshold = 0, initialSampling = initialSampling, 
                        family = stats::gaussian(), modality = 'ChromVAR_Associations',
                        numCores = numCores)

  return(chromSE_Assoc)

}




#' @title \code{General_Associations} Model features counts of one modality as a function of features counts from another modality (Generalized)
#'
#' @description \code{General_Associations} High-throughput zero-inlfated GLMM-based modeling for associating features between two ChAI General data objects. 
#' @param SE1 SummarizedExperiment object for measurement-type 1 from \code{importGeneralModality}
#' @param SE2 SummarizedExperiment object for measurement-type 2 from  \code{makeChromVAR} or \code{importGeneralModality}
#' @param assay1 - name of the assay to extract and use from SE1
#' @param assay2 - name of the assay to extract and use from SE2
#' @param sampleColumn - A string: the name of the column with Sample names from the metadata. 
#'                  Must be the same from SE1 and SE2. This is used for aligning SE1 and SE2
#' @param modelFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect)
#' @param ziFormula Zi Formula to test for zero-inflation within generalSE
#' @param sig1 A list of rows from SE1 to test. 
#' @param sig2 A list of rows from SE2 to test. 
#' @param allCombinations A boolean, whether to test all possible pair-wise combinations of  sig1 and  sig2. Default is TRUE. If False, it will require sig1 and sig2 to be the same length, and only test index-matched pairs (i.e. sig1[2] vs  sig2[2] )
#' @param family distribution family parameter, passed to glmmTMB to describe the data's distribution.
#'     Default is normal (gaussian()). See  \link[glmmTMB]{glmmTMB}.
#' @param initialSampling An integer. Default is 5. Represents the number of initial models to test when generating a null set (which is used when models fails). If your model fails often, increase this number or choose a better formula.
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 1.
#'
#' @return results a SummarizedExperiment containing modeling results. Assays are metrics related to the model coefficients,
#'          including the Estimate, Std_Error, df, t_value, p_value. Within each assay, each row corresponds to each row of
#'          the SummarizedExperiment and columns correspond to each fixed effect variable within the model.
#'          Any row metadata from the ExperimentObject (see rowData(ExperimentObj)) is preserved in the output. 
#'          The Residual matrix and the variance of the random effects are saved in the metadata slot of the output.
#'
#'
#'
#' @export
#' @keywords modeling_associations

General_Associations <- function(SE1, SE2, assay1, assay2, sampleColumn, 
                                 modelFormula, 
                                 ziFormula = ~0 ,
                                 sig1, sig2, 
                                 allCombinations = TRUE,
                                 family = stats::gaussian(), initialSampling = 5, numCores) {
  

  if(!isChAIObject(SE1, type = 'data', returnType = TRUE) %in%  c('General','Transformed')){

    stop('SE1 is not a ChAI General Modality Object, generated via importGeneralModality.')
  

  }else if(! isChAIObject(SE2, type = 'data', returnType = TRUE) %in% c('General', 'ChromVAR','Transformed')){

    stop('SE2 is neither a ChAI General Modality Object, generated via importGeneralModality, nor 
            a ChAI ChromVAR object, generated via makeChromVAR.')
  
  }
      
    
  ### The sample column must be unique identifiers for aligning samples. 
  ### verify that this is true
  if(any(duplicated(SE1@colData[,sampleColumn])) | any(duplicated(SE2@colData[,sampleColumn]))){
  
      stop('Duplicate values found with sampleColumn provided. Please ensure sample identifiers are unique within each object')
      
  }
      
   #Check whether samples align.     
  if(all(!SE1@colData[,sampleColumn] %in% SE2@colData[,sampleColumn]) |
            all(!SE2@colData[,sampleColumn] %in% SE1@colData[,sampleColumn])){
      stop(stringr::str_interp('samples names in ${sampleColumn} are not the same. Please ensure that sample names match in SE1 and SE2 via ${sampleColumn}.'))
  } else if(!all(SE2@colData[,sampleColumn] %in% SE1@colData[,sampleColumn]) |
      !all(SE1@colData[,sampleColumn] %in% SE2@colData[,sampleColumn])) {
       
       partialMatch <- intersect(SE2@colData[,sampleColumn] , 
                                 SE1@colData[,sampleColumn])
 
      warning(stringr::str_interp('Some samples names in ${sampleColumn} are not the same between modalities. Non-matching names will be dropped'))
      dropped = SE2@colData[,sampleColumn] %in% SE1@colData[,sampleColumn]
      generalDropped = SE1@colData[,sampleColumn] %in% SE2@colData[,sampleColumn]
      warning(stringr::str_interp(' ${sum(!dropped)} and ${sum(!generalDropped)} sample(s) dropped from SE2 and SE1, respectively'))

      SE1 <- subsetChAI(SE1, subsetBy = sampleColumn, 
                              groupList = partialMatch)
      SE2 <- subsetChAI(SE2, subsetBy = sampleColumn, 
                              groupList = partialMatch)
    }

 if(!all(SE1@colData[,sampleColumn] == SE2@colData[,sampleColumn])){
      message('Reordering SE1 and SE2 to match each other.')
      SE1 <- SE1[,order(SE1@colData[,sampleColumn])]
      SE2 <- SE2[,order(SE2@colData[,sampleColumn])]
  }

  if(any(c(colnames(SummarizedExperiment::colData(SE1)), 
      colnames(SummarizedExperiment::colData(SE2))) %in% c('exp1','exp2'))){

    stop('metadata of SE1 and/or SE2 contains a column that contains the name exp1 or exp2.',
    'exp1 and exp2 are hardcoded to represent the data from SE1 and SE2, not the metadata.
    Please remove these and try again.')

  }
 
  if(!all(sig2 %in% rownames(SE2))){
     stop('sig2 not found within SE2. Please read documentation.')
  }
    
  #Test whether sig1 and sig2 are found in their assays.
  if(!all(sig1 %in% rownames(SE1))){
     stop('sig1 not found within SE1. Please read documentation.')
  }

  #Test whether the formula is in the right format
  if(!(all.vars(stats::as.formula(modelFormula))[1] =='exp1' & any(all.vars(stats::as.formula(modelFormula)) %in% 'exp2'))){
    stop('modelFormula is not in the correct format. Data from SE2 will be used to predict SE1. Please format modelFormula as exp1 ~ exp2 + OtherFixedEffects + RandomEffect.')
  }
    
  if (methods::is(ziFormula, 'character')) {
    ziFormula <- stats::as.formula(ziFormula)
  }


  if((any(all.vars(stats::as.formula(ziFormula)) %in% 'exp1'))){
    stop('ziFormula is not in the correct format. exp1 should not be in the ziformula. Please format ziFormula as  ~ Factor1 + Factor2 + exp2. This is also optional and can be set to ~0 for non-zero-inflated modeling. ')
  }



  #Subset down each SummarizedExperiment to the rows of interest, and assays of interest. 
  newSE1 <- SE1[rownames(SE1)  %in% unique(sig1), ]
  newSE2 <- SE2[rownames(SE2)  %in% unique(sig2), ]
  SummarizedExperiment::assays(newSE1) <- SummarizedExperiment::assays(newSE1)[assay1]
  SummarizedExperiment::assays(newSE2) <- SummarizedExperiment::assays(newSE2)[assay2]

    
  if(allCombinations){

      sig1 = unique(sig1)
      sig2 = unique(sig2)
     cl <- parallel::makeCluster(numCores)
      #Find all combinations of sig1 and sig2 to test. 
      message('Compiling all pair-wise combinations')

      allCombos <- do.call('rbind', pbapply::pblapply(cl = cl, X = sig2, findCombo, List2 = sig1))

      parallel::stopCluster(cl)
      
  }else if(length(sig1) == length(sig2)){

        allCombos = data.frame(Var1 = sig2, Var2 = sig1)

  }else{
      
      stop('Length of sig1 and sig2 are not the same, so direct pairwise combinations cannot be made. Please set them to be the same length or set allCombinations = TRUE.')
      
  }
    
    
  generalAssociations <- .multiModalModeling(SE1 = newSE1, SE2 = newSE2, 
                        allCombos = allCombos, 
                        sampleColumn =  sampleColumn, continuousFormula = modelFormula,
                        ziFormula = ziFormula, zi_threshold =0, initialSampling = initialSampling, 
                        family = family, 
                        modality = 'General_Associations',
                        numCores = numCores)

  return(generalAssociations)

}




#' @title Internal function to run generating null results, in case of model failure when associations multiple modalities
#'
#' @description \code{generateNULL_Associations} Runs null results, either for glmmTMB
#' @param modelingData the data used for modeling. 
#' @param metaData the metadata associated with the data
#' @param continuousFormula The formula for the continuous data that should be used within glmmTMB. It should be in the
#'   format (exp ~ factors). All factors must be found in column names of the SE_Object colData (i.e. sample metadata).
#'   See \link[glmmTMB]{glmmTMB}.
#' @param ziFormula The formula for the zero-inflated data that should be used within glmmTMB. It should be in the
#'   format ( ~ factors). All factors must be found in column names of metaData
#' @param family family for data distribution to be used in the model
#' @param initialSampling Size of data to use for pilot
#' @param verbose Set TRUE to display additional messages. Default is FALSE.
#'
#' @return output_vector A linear model
#'
#' @noRd

generateNULL_Associations <- function(pilotCombos, continuousFormula, ziFormula, family, initialSampling, returnModels = FALSE){

  #Generate a list of models
  modelList <- lapply(pilotCombos, function(df) {

    tryCatch(
      {
        glmmTMB::glmmTMB(stats::as.formula(continuousFormula),
            ziformula = stats::as.formula(ziFormula),
            data = df,
            family = family,
            REML = TRUE)
       
      },
      error = function(e) {
        NA
      }
    )
  })

  names(modelList) <- names(pilotCombos)

  if(returnModels){
    return(modelList)
  }

  NAList <- unlist(lapply(modelList, function(x){
                    ## First identify all the pilot models that ran at all without errors. 
                   tmp1 <- all(is.na(x))
                   if(tmp1){ 
                    return(FALSE)
                   }else{
                     ## Then identify all the models that converged. 
                    tryCatch(
                      {
                        tmp1 <- summary(x)$coefficients
                        return(TRUE)
                      }, error = function(e){ return(FALSE)})
                   }
            }))
   
  if (all(!NAList)) {
    stop("For the initial sampling, every test model failed. Reconsider modelFormula or increase initial sampling size.")
  } else {
    idx <- which(NAList)
    # Did any of the models have both zero-inflated and continous portions?
    bothZI_Cont <- unlist(lapply(idx, function(x){
      ziDF <- summary(modelList[[x]])$coefficients$zi
      !is.null(ziDF) | sum(dim(ziDF)) != 0

    }))

    if(all(!bothZI_Cont) & !ziFormula %in% c('~ 0', '~0')){
      warning('No working models using the zero-inflated formula. Do you need to modify the zero-inflated formula?')
      modelRes <- modelList[[idx[1]]]
    }else if(ziFormula %in% c('~ 0', '~0')){
      modelRes <- modelList[[idx[1]]]
    }else {
      modelRes <- modelList[[idx[which(bothZI_Cont)[1]]]]
    }
    df <- pilotCombos[[1]]
    #Extract the first representative model. And use it to create a null template. 
    coeff2 <- summary(modelRes)$coefficients
    coeff <- lapply(coeff2, as.data.frame)
    coeff$cond[!is.na(coeff$cond)] <- NA
    rownames(coeff$cond)[grepl('(Intercept)',rownames(coeff$cond))] = 'Intercept'
    if(all(!bothZI_Cont)){
      combinedCoeff <- coeff$cond
    }else{
      coeff$zi[!is.na(coeff$zi)] <- NA
      rownames(coeff$zi)[grepl('(Intercept)',rownames(coeff$zi))] = 'Intercept'
      rownames(coeff$zi) <- paste('ZI', rownames(coeff$zi), sep ='_')
      combinedCoeff <- rbind(coeff$cond, coeff$zi)
    }
    
    Resid <- stats::resid(modelRes)
    
    if(!all(df$Sample %in% names(Resid))){
      NA_samples <- rep(NA, sum(!df$Sample %in% names(Resid)))
      names(NA_samples) <- df$Sample[!df$Sample %in% names(Resid)]
      Resid <- c(Resid, NA_samples)
    }
    Resid <- Resid[match(names(Resid),df$Sample)]
    Resid[!is.na(Resid)] <- NA
    varCorrObj <- glmmTMB::VarCorr(modelRes)
    if(is.null(varCorrObj$cond) & all(!bothZI_Cont)){
      varCorrObj <- list('cond' = list('NoRandomEffects'= NA), 'zi' = NULL)
      residual = c('Residual' = NA)
    } else if(is.null(varCorrObj$cond)){
      varCorrObj <- list('cond' = list('NoRandomEffects'= NA), 'zi' = list('None'= NA))
      residual = c('Residual' = NA)
    }else{
      residual = as.vector(attr(varCorrObj$cond, "sc")^2)
      names(residual) = 'Residual'
    }
    cond_other = unlist(varCorrObj$cond)
    names(cond_other) = paste('Cond', names(cond_other), sep = "_")
    
   
    if(!is.null(varCorrObj$zi)){
      zi_other = unlist(varCorrObj$zi)
      names(zi_other) = paste('ZI', names(zi_other), sep = "_")
      varcor_df <- c(cond_other, zi_other,residual)
    }else{
      varcor_df <- c(cond_other, residual)
    }
    varcor_df[!is.na(varcor_df)] = NA

    nullDFList <- list('Coeff' = combinedCoeff, 'Resid' = Resid, 'VCov'= varcor_df)

    rm(modelList)
  }
  return(nullDFList)
}

mat1 <- mat2 <- nullDFList <- metaData <- zi_threshold <- ziFormula <- continuousFormula <- modelingData <- List2 <- MetaDF <- family <- NULL

#' @title \code{individualAssociations}
#'
#' @description \code{individualAssociations} allows for generalized linear mixed effect modeling across multiple modalities,
#'  as long as samples are aligned. This is only designed for integrating datatypes with normal distributions.
#' @param x combination to test for associations. First index is the rowname from mat1, and second index is rowname from mat2 to test.
#'            mat1, mat2, and metadata1, as well as nullDFList should all be exported to the core beforehand.  
#'
#' @return A summarized experiment summarizing the output. 
#'
#'
#' @noRd


individualAssociations <- function(df, continuousFormula1, ziFormula1, family1, zi_threshold1, nullDFList1, modality1){
  
  #df = iterList1[[1]]
  #continuousFormula1 = iterList1[[2]]
  #ziformula1 = iterList1[[3]]
  #family1 = iterList1[[4]]
  #zi_threshold1 = iterList1[[5]]
  #nullDFList1 = iterList1[[6]]


  output_vector <- tryCatch(
    {
     

    if(modality1 != 'scATAC_Associations'  & all(ziFormula != '~ 0')){
         modelRes <- glmmTMB::glmmTMB(formula = exp1 ~ 1,
          ziformula = ~ 0,
          data = df,
          family = family1,
          REML = TRUE,
          control = glmmTMB::glmmTMBControl(parallel = 1)
        )
        
        sigZI <- DHARMa::testZeroInflation(modelRes,plot = FALSE)$p.value < 0.05
          
      }else{
      
          sigZI = FALSE
          
      }
    
    if(modality1 != 'scATAC_Associations'){
        
        if(sigZI){
            suppressWarnings(modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula1),
              ziformula = stats::as.formula(ziFormula1),
              data = df,
              family = family1,
              REML = TRUE,
              control = glmmTMB::glmmTMBControl(parallel = 1)
             ))
            
        }else{
         suppressWarnings( modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula1),
              ziformula = ~ 0,
              data = df,
              family = family1,
              REML = TRUE,
              control = glmmTMB::glmmTMBControl(parallel = 1)
            ))
         }
  
     }else if(sum(df$exp1 == 0, na.rm = TRUE)/length(df$exp1) == 0){
        suppressWarnings(modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula1),
          ziformula = ~ 0,
          data = df,
          family = family1,
          REML = TRUE,
          control = glmmTMB::glmmTMBControl(parallel = 1)
        ))
       
      }else if(sum(df$exp1 == 0, na.rm = TRUE)/length(df$exp1) <= zi_threshold1){
        df$exp1[df$exp1 == 0] = NA
        suppressWarnings(modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula1),
          ziformula = ~ 0,
          data = df,
          family = family1,
          REML = TRUE,
          control = glmmTMB::glmmTMBControl(parallel = 1)
        ))
       
      }else {
        suppressWarnings(modelRes <- glmmTMB::glmmTMB(stats::as.formula(continuousFormula1),
          ziformula = stats::as.formula(ziFormula1),
          data = df,
          family = family1,
          REML = TRUE,
          control = glmmTMB::glmmTMBControl(parallel = 1)
        ))
      }

      Coeff <- lapply(summary(modelRes)$coefficients, as.data.frame)
      rownames(Coeff[['cond']])[grepl('(Intercept)',rownames(Coeff[['cond']]))] = 'Intercept'
      if(sum(dim(Coeff$zi)) != 0){
        rownames(Coeff$zi)[grepl('(Intercept)',rownames(Coeff$zi))] = 'Intercept'
        rownames(Coeff$zi) <- paste('ZI', rownames(Coeff$zi), sep ='_')
      }else{
        Coeff$zi = nullDFList1$Coeff[grepl('ZI',rownames(nullDFList1$Coeff)),]
      }
      combinedCoeff <- rbind(Coeff$cond, Coeff$zi)


      Resid <- stats::resid(modelRes)
      
      #Clean up residuals. Data that is NA will be removed from the residuals, so we add them back in as NAs for the sake of completion. 
      if(!all(df$Sample %in% names(Resid))){
        NA_samples <- rep(NA, sum(!df$Sample %in% names(Resid)))
        names(NA_samples) <- df$Sample[!df$Sample %in% names(Resid)]
        Resid <- c(Resid, NA_samples)
      }
      Resid <- Resid[match(names(Resid),df$Sample)]

      #Now process the variance from random effects. 
      varcor_df <- tryCatch({
        varCorrObj <- glmmTMB::VarCorr(modelRes)
        cond_other = unlist(varCorrObj$cond)
        names(cond_other) = paste('Cond', names(cond_other), sep = "_")
        residual = as.vector(attr(varCorrObj$cond, "sc")^2)
        names(residual) = 'Residual'

        #Process variance
        if(!is.null(varCorrObj$zi)){
          zi_other = unlist(varCorrObj$zi)
          names(zi_other) = paste('ZI', names(zi_other), sep = "_")
          varcor_df <- c(cond_other, zi_other,residual)
        }else if(all(df$exp1 !=0, na.rm = TRUE)){
          subNull = nullDFList1[grepl('ZI_', names(nullDFList1))]
          zi_other = rep(0, length(subNull))
          names(zi_other) = names(subNull)
          varcor_df <- c(cond_other, zi_other,residual)
        }else {
          varcor_df <- c(cond_other, residual)
        }
        varcor_df
      }, error = function(e){
        nullDFList1$VCov
      })
      
      list('Coeff' = combinedCoeff, 'Resid' = Resid, 'VCov'= varcor_df)
    },
    error = function(e) {
      nullDFList1
    }
  )
  return(output_vector)
}


#' @title \code{alignSamples}
#'
#' @description \code{alignSamples} Subsets two summarized experiments to matching samples and aligns them in the same order
#' @param SE1 
#' @param SE2 

#'
#' @return A summarized experiment summarizing the output. 
#'
#'
#' @noRd

#' @title \code{multiModalModeling}
#'
#' @description \code{multiModalModeling} allows for generalized linear mixed effect modeling across multiple modalities,
#'  as long as samples are aligned. This is only designed for integrating datatypes with normal distributions.
#' @param mat1 SummarizedExperiment object for measurement-type 1. 
#' @param mat2 SummarizedExperiment object for measurement-type 2. 
#' @param allCombos all combinations of rows from mat1 and mat2 to test. 
#' @param metaData - metadata from samples
#' @param continuousFormula : Formula used for modeling. Must be in the form exp1 ~ exp2 + other factors + (1|RandomEffect)
#' @param ziFormula : Formula used for modeling the zero-inflated component. Must be in the form  ~ exp2 + other factors + (1|RandomEffect)
#' @param family distribution family to be provided to glmmTMB
#' @param numCores Optional, the number of cores to use with multiprocessing. Default is 1.
#'
#' @return A summarized experiment summarizing the output. 
#'
#'  
#'
#'
#' @noRd

.multiModalModeling <- function(SE1, SE2, allCombos, sampleColumn, continuousFormula, ziFormula, zi_threshold, initialSampling, family, modality, numCores=1) {
  
  if(any(dim(allCombos) ==0)){
    stop('No combinations found, so there is nothing to test for associations. Please check that the input lists are not empty.')
  }
  ## Extract matrices and metadata
  mat1 <- SummarizedExperiment::assays(SE1)[[1]]
  mat2 <- SummarizedExperiment::assays(SE2)[[1]]

  if(any(modality %in% c('GeneTile','scATAC_Associations'))){
    mat1 <- log2(mat1 + 1)
  }
    
  if(any(modality %in% c('GeneTile'))){
    mat2 <- log2(mat2 + 1)
  }
    
  ### The sample column must be unique identifiers for aligning samples. 
  ### verify that this is true
  if(any(duplicated(SE1@colData[,sampleColumn])) | any(duplicated(SE2@colData[,sampleColumn]))){
  
      stop('Duplicate values found with sampleColumn provided. Please ensure sample identifiers are unique within each object')
      
  }

  metaData1 <- SummarizedExperiment::colData(SE1)
  metaData2 <- SummarizedExperiment::colData(SE2)

  unique2 <- colnames(metaData2)[!colnames(metaData2) %in% colnames(metaData1)]
  if(length(unique2) > 0){
    metaData <- dplyr::left_join(as.data.frame(metaData1), 
                as.data.frame(metaData2[,c(unique2, sampleColumn)]), by = sampleColumn)
  }else{
    metaData = metaData1
  }
                                

  ## Log transform the FragmentNumbers so as to stabilize the model. But only if FragmentCounts is in the model. Same for CellCounts.
  if(any(colnames(metaData) %in% c('FragmentCounts'))){
    metaData$rawFragmentCounts = metaData$FragmentCounts
    metaData$FragmentCounts <- log10(metaData$FragmentCounts + 1)
  }
  if(any(colnames(metaData) %in% c('CellCounts'))){
    metaData$rawCellCounts = metaData$CellCounts
    metaData$CellCounts <- log10(metaData$CellCounts +1)
  }


  if(numCores <= 1){
    stop('numCores must be greater than 1. This method is meant to be parallelized.')
  }

  if (any(c('exp1','exp2') %in% colnames(metaData))) {
    stop("Variables for exp1 and exp2 are within the metaData.")
  }

  if (!methods::is(continuousFormula, "formula")) {
    stop("continuousFormula was not provided as a formula.")
  }
  if (!methods::is(ziFormula,"formula") & !is.null(ziFormula) ) {
    stop("ziFormula was not provided as a formula.")
  }

  #Transform in character strings for multithreading. 
  continuousFormula <- deparse(continuousFormula)
  ziFormula <- deparse(ziFormula)

  if (!all(all.vars(continuousFormula) %in% c("exp1", "exp2", colnames(metaData)))) {
    stop("Model formula is not in the correct format (exp1 ~ factors) or model factors are not found in column names of metadata.")
  }

  if (!all(all.vars(ziFormula) %in% c( "exp2", colnames(metaData)))) {
    stop("factors from the ziFormula were not found in the metadata.")
  }

  if (any(colnames(metaData) %in% c("exp1", "exp2"))) {
    stop("Object metadata includes columns named exp1 and/or exp2, which will cause errors downstream. Please rename those columns.")
  }

  # convert allCombos into a list to iterate ove (need to reverse order for modeling, since expand grid tends to flip it.)
               
                
  message('Joining data for each pair.')
                         

  comboList = pbapply::pblapply(cl = NULL, X = c(1:dim(allCombos)[1]), function(x){
        
      newIndex = rev(as.character(unlist(allCombos[x,])))
      data.frame(exp1 = unlist(mat1[newIndex[[1]],]), exp2 = unlist(mat2[newIndex[[2]],]), metaData, stringsAsFactors= FALSE)
      
      })       
                                  
  names(comboList) <- unlist(lapply(1:dim(allCombos)[1], function(x) 
              paste(rev(as.character(unlist(allCombos[x,]))),collapse = '__')
      ))



  #Pull out random pairs to test for the null template
  #if too few comparisons, then set initial sampling to be all combinations. 
  if(initialSampling > length(allCombos)){
  
      initialSampling = length(allCombos)
      
  }
  pilotIndices <- sample(x = 1:dim(allCombos)[1], size = initialSampling, replace = FALSE)
      
                                
  #Generate the nullDFList, incase of model failure. 
  nullDFList <- generateNULL_Associations(pilotCombos = comboList[pilotIndices],
                        continuousFormula = continuousFormula, ziFormula = ziFormula,
                       family = family, initialSampling = initialSampling)


  cl <- parallel::makeCluster(numCores)
  #export glmmTMB to each cores
  parallel::clusterEvalQ(cl, {
        library('glmmTMB')
      })
    
  #Test each individual combination.
  message('Modeling each pair.')
  allRes <- pbapply::pblapply(cl = cl, X =comboList, individualAssociations, 
                             continuousFormula1 = continuousFormula,
                             ziFormula1 = ziFormula, 
                             family1= family,
                             zi_threshold1 = zi_threshold,
                             nullDFList=nullDFList, 
                              modality1= modality)

  # stop parallel processing
  parallel::stopCluster(cl)

  rownamesList <- names(comboList)

  outputList <- processModelOutputs(modelOutputList=allRes, nullDFList = nullDFList, 
                      rownamesList = rownamesList,
                                  SummarizedExperimentObj = SE1, ranged = FALSE, returnList = TRUE) 

  
  # Process rowData. 
  rowData1 <- as.data.frame(SummarizedExperiment::rowData(SE1))
  rowData2 <- as.data.frame(SummarizedExperiment::rowData(SE2))
  if(any(dim(rowData1) ==0) & any(dim(rowData1) == 0)){
    #No row data available
    allRowData = data.frame(Obj1 = allCombos$Var2, 
                            Obj2 = allCombos$Var1)
    rownames(allRowData) = paste(allCombos$Var2,  allCombos$Var1, sep = "__")
      
  }else if(any(dim(rowData1) ==0)){
    #Only rowData from SE2
    allRowData <- rowData2[match(allCombos$Var1, rownames(rowData2)),,drop=FALSE]
    allRowData$Obj2 = allCombos$Var1
    allRowData = cbind(data.frame(Obj1 = allCombos$Var2), 
                    allRowData)
    rownames(allRowData) = paste(allCombos$Var2,  allCombos$Var1, sep = "__")
    
      
  }else if(any(dim(rowData2) ==0)){
    #Only rowData from SE1
    allRowData <- rowData1[match(allCombos$Var2, rownames(rowData1)),,drop=FALSE]
    allRowData$Obj1 = allCombos$Var2
    allRowData = cbind(allRowData,
                       data.frame(Obj2 = allCombos$Var1))
    rownames(allRowData) = paste(allCombos$Var2,  allCombos$Var1, sep = "__")

  }else{

    allRowData1 <- as.data.frame(rowData1[
        match(allCombos$Var2, rownames(rowData1)),,drop=FALSE])
    colnames(allRowData1) <- colnames(rowData1)
    allRowData1$Obj1 = allCombos$Var2
    rownames(allRowData1) = paste(allCombos$Var2,  allCombos$Var1, sep = "__")
    allRowData2 <-  as.data.frame(rowData2[
        match(allCombos$Var1, rownames(rowData2)),,drop=FALSE])
    colnames(allRowData2) <- colnames(rowData2)
    allRowData2$Obj2 = allCombos$Var1
    rownames(allRowData2) = paste(allCombos$Var2,  allCombos$Var1, sep = "__")
    allRowData <- cbind(allRowData1, allRowData2)
  }
      
  residualDF <- outputList[[2]]
  colnames(residualDF)[is.na(colnames(residualDF))] = rownames(SummarizedExperiment::colData(SE1))[
      !rownames(SummarizedExperiment::colData(SE1)) %in% colnames(residualDF)]
                                
  #Create ResidualObject, and metadata list.
  ResidualSE <- SummarizedExperiment::SummarizedExperiment(
                      list('Residual' =  residualDF),
                      colData = SummarizedExperiment::colData(SE1),
                      rowData = allRowData,
                      metadata = S4Vectors::metadata(SE1)
              )
              
  #Package up the metadata list. 
  metaDataList <- list('Residuals' = ResidualSE,
                      'RandomEffectVariance' = outputList[[3]])

  #Bind results into one data.frame.
  resDF <- SummarizedExperiment::SummarizedExperiment(outputList[[1]],
                    rowData = allRowData,
                    metadata= metaDataList)
  resDF@metadata = append(resDF@metadata, list('Type' = modality))

  # concatenate results and return
  return(resDF)
}
